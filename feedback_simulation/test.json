[
  {
    "question": "What is the average and the maximum capacity of all stadiums?",
    "db_id": "concert_singer",
    "gold_parse": "SELECT avg(capacity) ,  max(capacity) FROM stadium",
    "feedback": "Swap average average with average capacity .",
    "predicted_parse_with_values": "select avg ( Average ) , max ( Capacity ) from stadium",
    "template_feedback": "find average capacity in place of average average .",
    "predicted_parse_explanation": [
      "find the average average and maximum capacity in stadium table"
    ],
    "primary_span": [
      [
        0,
        2
      ]
    ],
    "secondary_span": [
      [
        3,
        8
      ]
    ],
    "edits": [
      "average capacity",
      "average average"
    ],
    "edits_original": "< select > add average capacity </ select > < select > remove average average </ select >"
  },
  {
    "question": "What is the name and capacity of the stadium  with the most concerts after 2013?",
    "db_id": "concert_singer",
    "gold_parse": "SELECT T2.name ,  T2.capacity FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  >=  2014 GROUP BY T2.stadium_id ORDER BY count(*) DESC LIMIT 1",
    "feedback": "In step 2 replace 2014 with 2013.",
    "predicted_parse_with_values": "select T2.Name , T2.Capacity from concert as T1 join stadium as T2 on T1.Stadium_ID = T2.Stadium_ID where T1.Year > 2014 group by T1.Stadium_ID order by count ( * ) desc limit 1",
    "template_feedback": "in step 2 , consider the year greater than or equals 2014 conditions in place of the year greater than 2014 conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in concert table , find the corresponding rows in stadium table",
      "Step 2: only keep the results of step 1 whose year greater than 2014",
      "Step 3: find the number of rows of each value of concert 's stadium id the results of step 2",
      "Step 4: find the name and capacity the results of step 2 with largest value in the results of step 3"
    ],
    "primary_span": [
      [
        4,
        12
      ]
    ],
    "secondary_span": [
      [
        13,
        22
      ]
    ],
    "edits": [
      "year greater than or equals to 2014",
      "year greater than 2014"
    ],
    "edits_original": "< where > add year greater than or equals to 2014 </ where > < where > remove year greater than 2014 </ where >"
  },
  {
    "question": "What are the names of the singers and number of concerts for each person?",
    "db_id": "concert_singer",
    "gold_parse": "SELECT T2.name ,  count(*) FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id GROUP BY T2.singer_id",
    "feedback": "Need to find number of the corresponding rows to each value of singer in concert table .",
    "predicted_parse_with_values": "select Name , count ( * ) from singer group by Name",
    "template_feedback": "additionally use the information from the singer in concert table besides the singer table . find for each value of singer 's singer id in place of name .",
    "predicted_parse_explanation": [
      "find each value of name in singer table along with the number of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        0,
        9
      ],
      [
        15,
        23
      ]
    ],
    "secondary_span": [
      [
        10,
        14
      ],
      [
        24,
        28
      ]
    ],
    "edits": [
      "singer in concert",
      "singer id",
      "name"
    ],
    "edits_original": "< from > add singer in concert </ from > < groupBy > add singer id </ groupBy > < groupBy > remove name </ groupBy >"
  },
  {
    "question": "How many pets are owned by students that have an age greater than 20?",
    "db_id": "pets_1",
    "gold_parse": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.age  >  20",
    "feedback": "Substitute pet age with corresponding student 's age .",
    "predicted_parse_with_values": "select count ( * ) from Pets where pet_age > 20",
    "template_feedback": "use student table and has pet table in place of pets table . consider the age greater than 20 conditions in place of the pet age greater than 20 conditions .",
    "predicted_parse_explanation": [
      "find the number of rows in pets table whose pet age greater than 20"
    ],
    "primary_span": [
      [
        0,
        6
      ],
      [
        13,
        19
      ]
    ],
    "secondary_span": [
      [
        7,
        12
      ],
      [
        20,
        30
      ]
    ],
    "edits": [
      "student",
      "has pet",
      "pets",
      "age greater than 20",
      "pet age greater than 20"
    ],
    "edits_original": "< from > add student </ from > < from > add has pet </ from > < from > remove pets </ from > < where > add age greater than 20 </ where > < where > remove pet age greater than 20 </ where >"
  },
  {
    "question": "How many dog pets are raised by female students?",
    "db_id": "pets_1",
    "gold_parse": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T2.petid  =  T3.petid WHERE T1.sex  =  'F' AND T3.pettype  =  'dog'",
    "feedback": "In step 2 also ensure pet type equals dog .",
    "predicted_parse_with_values": "select count ( * ) from Student as T1 join Has_Pet as T2 on T1.StuID = T2.StuID join Pets as T3 on T2.PetID = T3.PetID where T1.Sex = \"F\"",
    "template_feedback": "in step 2 , additionally make sure that pet type equals dog .",
    "predicted_parse_explanation": [
      "Step 1: for each row in student table , find the corresponding rows in has pet table and in pets table",
      "Step 2: find the number of rows of the results of step 1 whose sex equals F"
    ],
    "primary_span": [
      [
        4,
        12
      ]
    ],
    "secondary_span": [],
    "edits": [
      "pet type equals \"dog\""
    ],
    "edits_original": "< where > add pet type equals \" dog \" </ where >"
  },
  {
    "question": "Find the name of students who have both cat and dog pets.",
    "db_id": "pets_1",
    "gold_parse": "SELECT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' INTERSECT SELECT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog'",
    "feedback": "In Step 2 and Step 3 Find both first name and last name .",
    "predicted_parse_with_values": "select T3.Fname from Pets as T1 join Has_Pet as T2 on T1.PetID = T2.PetID join Student as T3 on T2.StuID = T3.StuID where T1.PetType = \"cat\" intersect select T6.LName from Pets as T4 join Has_Pet as T5 on T4.PetID = T5.PetID join Student as T6 on T5.StuID = T6.StuID where T4.PetType = \"dog\"",
    "template_feedback": "in step 4 , find first name in place of last name .",
    "predicted_parse_explanation": [
      "Step 1: for each row in pets table , find the corresponding rows in has pet table and in student table",
      "Step 2: find the first name of the results of step 1 whose pet type equals cat",
      "Step 3: for each row in pets table , find the corresponding rows in has pet table and in student table",
      "Step 4: find the last name of the results of step 3 whose pet type equals dog",
      "Step 5: show the rows that are in both the results of step 2 and step 4"
    ],
    "primary_span": [
      [
        4,
        6
      ]
    ],
    "secondary_span": [
      [
        7,
        12
      ]
    ],
    "edits": [
      "first name",
      "last name"
    ],
    "edits_original": "< select > add first name </ select > < select > remove last name </ select >"
  },
  {
    "question": "What type of pet is the youngest animal, and how much does it weigh?",
    "db_id": "pets_1",
    "gold_parse": "SELECT pettype ,  weight FROM pets ORDER BY pet_age LIMIT 1",
    "feedback": "There should be weight in place of first pet age .",
    "predicted_parse_with_values": "select PetType , pet_age from Pets order by pet_age limit 1",
    "template_feedback": "find weight in place of pet age .",
    "predicted_parse_explanation": [
      "find the pet type and pet age in pets table with smallest value of pet age"
    ],
    "primary_span": [
      [
        0,
        1
      ]
    ],
    "secondary_span": [
      [
        2,
        7
      ]
    ],
    "edits": [
      "weight",
      "pet age"
    ],
    "edits_original": "< select > add weight </ select > < select > remove pet age </ select >"
  },
  {
    "question": "What are the different first names and ages of the students who do have pets?",
    "db_id": "pets_1",
    "gold_parse": "SELECT DISTINCT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid",
    "feedback": "Find ensuring their student id is also present in has pet table .",
    "predicted_parse_with_values": "select Fname , Age from Student",
    "template_feedback": "additionally use the information from the has pet table besides the student table . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "find the first name and age in student table"
    ],
    "primary_span": [
      [
        0,
        8
      ],
      [
        14,
        21
      ]
    ],
    "secondary_span": [
      [
        9,
        13
      ]
    ],
    "edits": [
      "distinct",
      "has pet"
    ],
    "edits_original": "< select > add distinct </ select > < from > add has pet </ from >"
  },
  {
    "question": "For students who have pets, how many pets does each student have?",
    "db_id": "pets_1",
    "gold_parse": "SELECT count(*) ,  T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid GROUP BY T1.stuid",
    "feedback": "Find number of each value of student id in has pet table along with corresponding count .",
    "predicted_parse_with_values": "select count ( * ) from Pets",
    "template_feedback": "use student table and has pet table in place of pets table . find for each value of student 's student id . additionally find student 's student id .",
    "predicted_parse_explanation": [
      "find the number of rows in pets table"
    ],
    "primary_span": [
      [
        0,
        6
      ],
      [
        13,
        22
      ],
      [
        23,
        29
      ]
    ],
    "secondary_span": [
      [
        7,
        12
      ]
    ],
    "edits": [
      "student id",
      "student",
      "has pet",
      "pets",
      "student id"
    ],
    "edits_original": "< select > add student id </ select > < from > add student </ from > < from > add has pet </ from > < from > remove pets </ from > < groupBy > add student id </ groupBy >"
  },
  {
    "question": "Find the last name of the student who has a cat that is age 3.",
    "db_id": "pets_1",
    "gold_parse": "SELECT T1.lname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pet_age  =  3 AND T3.pettype  =  'cat'",
    "feedback": "Swap age with corresponding pet age . And make sure corresponding pet type equals cat .",
    "predicted_parse_with_values": "select LName from Student where Age = 3",
    "template_feedback": "additionally use the information from the pets table and has pet table besides the student table . consider the pet age equals 3 and pet type equals cat conditions in place of the age equals 3 conditions .",
    "predicted_parse_explanation": [
      "find the last name in student table whose age equals 3"
    ],
    "primary_span": [
      [
        0,
        11
      ],
      [
        17,
        28
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ],
      [
        29,
        37
      ]
    ],
    "edits": [
      "has pet",
      "pets",
      "pet age equals 3",
      "pet type equals \"cat\"",
      "age equals 3"
    ],
    "edits_original": "< from > add has pet </ from > < from > add pets </ from > < where > add pet age equals 3 </ where > < where > add pet type equals \" cat \" </ where > < where > remove age equals 3 </ where >"
  },
  {
    "question": "Find the make and production time of the cars that were produced in the earliest year?",
    "db_id": "car_1",
    "gold_parse": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA)",
    "feedback": "Replace second \"Make\" with \"Year\".",
    "predicted_parse_with_values": "select T2.Make , T2.Make from cars_data as T1 join car_names as T2 on T1.Id = T2.MakeId order by T1.Year limit 1",
    "template_feedback": "in step 2 , additionally make sure that year is equals minimum year cars data . additionally find year . you should not find the smallest of the results . show me all the results .",
    "predicted_parse_explanation": [
      "Step 1: for each row in cars data table , find the corresponding rows in car names table",
      "Step 2: find the make and make of the results of step 1 with smallest value of year"
    ],
    "primary_span": [
      [
        4,
        15
      ],
      [
        16,
        19
      ],
      [
        20,
        35
      ]
    ],
    "secondary_span": [],
    "edits": [
      "year",
      "make",
      "year equals SUBS1",
      "year",
      "1",
      "minimum year",
      "cars data"
    ],
    "edits_original": "< select > add year </ select > < select > remove make </ select > < where > add year equals SUBS1 </ where > < orderBy > remove year </ orderBy > < limit > remove 1 </ limit > < select > add minimum year </ select > < from > add cars data </ from >"
  },
  {
    "question": "What is the name of each continent and how many car makers are there in each one?",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent",
    "feedback": "Find continents 's continents with count of corresponding country id in car makers table .",
    "predicted_parse_with_values": "select T1.Continent , count ( * ) from continents as T1 join countries as T2 on T1.ContId = T2.Continent group by T2.Continent",
    "template_feedback": "in step 1 , additionally use the information from the car makers table . in step 2 , find for each value of continents 's continent in place of countries 's continent .",
    "predicted_parse_explanation": [
      "Step 1: for each row in continents table , find the corresponding rows in countries table",
      "Step 2: find each value of countries 's continent of the results of step 1 along with the number of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        4,
        13
      ],
      [
        18,
        25
      ]
    ],
    "secondary_span": [
      [
        26,
        32
      ]
    ],
    "edits": [
      "car makers"
    ],
    "edits_original": "< from > add car makers </ from >"
  },
  {
    "question": "What is the accelerate of the car make amc hornet sportabout (sw)?",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)'",
    "feedback": "In step 2 remove \"and model equals chevrolet\" phrase .",
    "predicted_parse_with_values": "select T1.Accelerate from cars_data as T1 join car_names as T2 on T1.Id = T2.MakeId where T2.Make = \"amc hornet sportabout (sw)\" and T2.Model = \"chevrolet\"",
    "template_feedback": "in step 2 , remove the model equals chevrolet conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in cars data table , find the corresponding rows in car names table",
      "Step 2: find the accelerate of the results of step 1 whose make equals amc hornet sportabout ( sw ) and model equals chevrolet"
    ],
    "primary_span": [
      [
        4,
        10
      ]
    ],
    "secondary_span": [],
    "edits": [
      "model equals \"chevrolet\""
    ],
    "edits_original": "< where > remove model equals \" chevrolet \" </ where >"
  },
  {
    "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)'",
    "feedback": "Remove \"summation of\" and \"and model equals chevrolet\" phrase , swap model with maker from step 2.",
    "predicted_parse_with_values": "select sum ( T1.Accelerate ) from cars_data as T1 join car_names as T2 on T1.Id = T2.MakeId where T2.Model = \"amc hornet sportabout (sw)\" and T2.Model = \"chevrolet\"",
    "template_feedback": "in step 2 , consider the make equals amc hornet sportabout ( sw ) conditions in place of the model equals chevrolet and model equals amc hornet sportabout ( sw ) conditions . find accelerate in place of summation of accelerate .",
    "predicted_parse_explanation": [
      "Step 1: for each row in cars data table , find the corresponding rows in car names table",
      "Step 2: find the summation of accelerate of the results of step 1 whose model equals amc hornet sportabout ( sw ) and model equals chevrolet"
    ],
    "primary_span": [
      [
        4,
        14
      ],
      [
        33,
        34
      ]
    ],
    "secondary_span": [
      [
        15,
        32
      ],
      [
        35,
        41
      ]
    ],
    "edits": [
      "accelerate",
      "summation of accelerate",
      "make equals \"amc hornet sportabout (sw)\"",
      "model equals \"amc hornet sportabout (sw)\"",
      "model equals \"chevrolet\""
    ],
    "edits_original": "< select > add accelerate </ select > < select > remove summation of accelerate </ select > < where > add make equals \" amc hornet sportabout ( sw ) \" </ where > < where > remove model equals \" amc hornet sportabout ( sw ) \" </ where > < where > remove model equals \" chevrolet \" </ where >"
  },
  {
    "question": "How many car models are produced in the usa?",
    "db_id": "car_1",
    "gold_parse": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa'",
    "feedback": "Swap countries table with model list table . Find whose corresponding maker of car makers 's country name equals usa .",
    "predicted_parse_with_values": "select count ( * ) from countries where CountryName = \"usa\"",
    "template_feedback": "additionally use the information from the model list table and car makers table besides the countries table .",
    "predicted_parse_explanation": [
      "find the number of rows in countries table whose country name equals usa"
    ],
    "primary_span": [
      [
        0,
        12
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ]
    ],
    "edits": [
      "model list",
      "car makers"
    ],
    "edits_original": "< from > add model list </ from > < from > add car makers </ from >"
  },
  {
    "question": "What is the count of the car models produced in the United States?",
    "db_id": "car_1",
    "gold_parse": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa'",
    "feedback": "Need to find number of car model whose countries  's country name equals United States .",
    "predicted_parse_with_values": "select count ( * ) from countries where CountryName = \"usa\"",
    "template_feedback": "additionally use the information from the model list table and car makers table besides the countries table .",
    "predicted_parse_explanation": [
      "find the number of rows in countries table whose country name equals usa"
    ],
    "primary_span": [
      [
        0,
        12
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ]
    ],
    "edits": [
      "model list",
      "car makers"
    ],
    "edits_original": "< from > add model list </ from > < from > add car makers </ from >"
  },
  {
    "question": "What are the countries having at least one car maker? List name and id.",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.CountryName ,  T1.CountryId FROM COUNTRIES AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.CountryId HAVING count(*)  >=  1",
    "feedback": "Whose country id of countries table is also present in country id of car makers table .",
    "predicted_parse_with_values": "select CountryName , CountryId from countries",
    "template_feedback": "additionally use the information from the car makers table besides the countries table . find for each value of country id whose number of rows greater than or equals 1 .",
    "predicted_parse_explanation": [
      "find the country name and country id in countries table"
    ],
    "primary_span": [
      [
        0,
        8
      ],
      [
        14,
        30
      ]
    ],
    "secondary_span": [
      [
        9,
        13
      ]
    ],
    "edits": [
      "car makers",
      "country id",
      "number of rows greater than or equals to 1"
    ],
    "edits_original": "< from > add car makers </ from > < groupBy > add country id </ groupBy > < having > add number of rows greater than or equals to 1 </ having >"
  },
  {
    "question": "What are the names and ids of all countries with at least one car maker?",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.CountryName ,  T1.CountryId FROM COUNTRIES AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.CountryId HAVING count(*)  >=  1",
    "feedback": "In step 1 substitute country id in countries table with country in car makers table.",
    "predicted_parse_with_values": "select CountryName , CountryId from countries group by CountryId having count ( * ) > = 1",
    "template_feedback": "in step 1 , additionally use the information from the car makers table besides the countries table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of country id in countries table",
      "Step 2: find the country name and country id in countries table whose corresponding value in step 1 is greater than or equals 1"
    ],
    "primary_span": [
      [
        4,
        12
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ]
    ],
    "edits": [
      "car makers"
    ],
    "edits_original": "< from > add car makers </ from >"
  },
  {
    "question": "What are the names of all European countries with at least 3 manufacturers?",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3",
    "feedback": "Find countries 's country name whose corresponding continents equals Europe , and count of car makers 's id equals or greater than 3.",
    "predicted_parse_with_values": "select T2.CountryName from continents as T1 join countries as T2 on T1.ContId = T2.Continent where T1.Continent = \"europe\" group by T2.CountryName having count ( * ) > = 3",
    "template_feedback": "in step 1 , additionally use the information from the car makers table .",
    "predicted_parse_explanation": [
      "Step 1: for each row in continents table , find the corresponding rows in countries table",
      "Step 2: only keep the results of step 1 whose continents 's continent equals europe",
      "Step 3: find the number of rows of each value of country name the results of step 2",
      "Step 4: find the country name the results of step 2 whose corresponding value in step 3 is greater than or equals 3"
    ],
    "primary_span": [
      [
        4,
        13
      ]
    ],
    "secondary_span": [],
    "edits": [
      "car makers"
    ],
    "edits_original": "< from > add car makers </ from >"
  },
  {
    "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1",
    "feedback": "Interchange horsepower with mpg in step 2.",
    "predicted_parse_with_values": "select T2.Model from cars_data as T1 join car_names as T2 on T1.Id = T2.MakeId order by T1.Horsepower desc limit 1",
    "template_feedback": "in step 2 , order the results by mpg in place of horsepower .",
    "predicted_parse_explanation": [
      "Step 1: for each row in cars data table , find the corresponding rows in car names table",
      "Step 2: find the model of the results of step 1 with largest value of horsepower"
    ],
    "primary_span": [
      [
        4,
        8
      ]
    ],
    "secondary_span": [
      [
        9,
        13
      ]
    ],
    "edits": [
      "mpg",
      "horsepower"
    ],
    "edits_original": "< orderBy > add mpg </ orderBy > < orderBy > remove horsepower </ orderBy >"
  },
  {
    "question": "What is the car wmodel with the highest mpg?",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1",
    "feedback": "Swap mpg of cars data table with model of car names table. maker sure of correspondence .",
    "predicted_parse_with_values": "select MPG from cars_data order by MPG desc limit 1",
    "template_feedback": "additionally use the information from the car names table besides the cars data table . find model in place of mpg .",
    "predicted_parse_explanation": [
      "find the mpg in cars data table with largest value of mpg"
    ],
    "primary_span": [
      [
        0,
        8
      ],
      [
        15,
        16
      ]
    ],
    "secondary_span": [
      [
        9,
        14
      ],
      [
        17,
        21
      ]
    ],
    "edits": [
      "model",
      "mpg",
      "car names"
    ],
    "edits_original": "< select > add model </ select > < select > remove mpg </ select > < from > add car names </ from >"
  },
  {
    "question": "What is the maximum accelerate for all the different cylinders?",
    "db_id": "car_1",
    "gold_parse": "SELECT max(Accelerate) ,  Cylinders FROM CARS_DATA GROUP BY Cylinders",
    "feedback": "Ensure to find for each unique value of cylinders .",
    "predicted_parse_with_values": "select max ( Accelerate ) from cars_data",
    "template_feedback": "find for each value of cylinders . additionally find cylinders .",
    "predicted_parse_explanation": [
      "find the maximum accelerate in cars data table"
    ],
    "primary_span": [
      [
        0,
        6
      ],
      [
        7,
        10
      ]
    ],
    "secondary_span": [],
    "edits": [
      "cylinders",
      "cylinders"
    ],
    "edits_original": "< select > add cylinders </ select > < groupBy > add cylinders </ groupBy >"
  },
  {
    "question": "Which model has the most version(make) of cars?",
    "db_id": "car_1",
    "gold_parse": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1",
    "feedback": "In step 1 Supersede model list table with car names table. Ensure Correspondence in step 2.",
    "predicted_parse_with_values": "select Model from model_list group by Model order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , use car names table in place of model list table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of model in model list table",
      "Step 2: find the model in model list table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        7
      ]
    ],
    "secondary_span": [
      [
        8,
        14
      ]
    ],
    "edits": [
      "car names",
      "model list"
    ],
    "edits_original": "< from > add car names </ from > < from > remove model list </ from >"
  },
  {
    "question": "Which makers designed more than 3 car models? List full name and the id.",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3",
    "feedback": "In Step 1 Replace Id in car makers table with maker in model list",
    "predicted_parse_with_values": "select FullName , Id from car_makers group by Id having count ( * ) > 3",
    "template_feedback": "in step 1 , additionally use the information from the model list table besides the car makers table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of id in car makers table",
      "Step 2: find the full name and id in car makers table whose corresponding value in step 1 is greater than 3"
    ],
    "primary_span": [
      [
        4,
        12
      ]
    ],
    "secondary_span": [
      [
        13,
        18
      ]
    ],
    "edits": [
      "model list"
    ],
    "edits_original": "< from > add model list </ from >"
  },
  {
    "question": "What is the maximum miles per gallon of the car with 8 cylinders or produced before 1980?",
    "db_id": "car_1",
    "gold_parse": "SELECT mpg FROM CARS_DATA WHERE Cylinders  =  8 OR YEAR  <  1980 ORDER BY mpg DESC LIMIT 1",
    "feedback": "Need to confirm that cylinders equals 8 or year less than 1980.",
    "predicted_parse_with_values": "select max ( MPG ) from cars_data where Cylinders > 8 or Year > 1980",
    "template_feedback": "consider the year less than 1980 or cylinders equals 8 conditions in place of the cylinders greater than 8 or year greater than 1980 conditions . find mpg in place of maximum mpg . find the result with the largest mpg .",
    "predicted_parse_explanation": [
      "find the maximum mpg in cars data table whose cylinders greater than 8 or year greater than 1980"
    ],
    "primary_span": [
      [
        0,
        10
      ],
      [
        26,
        27
      ],
      [
        34,
        41
      ]
    ],
    "secondary_span": [
      [
        11,
        25
      ],
      [
        28,
        33
      ]
    ],
    "edits": [
      "mpg",
      "maximum mpg",
      "cylinders equals 8 or year less than 1980",
      "cylinders greater than 8 or year greater than 1980",
      "mpg",
      "descending",
      "1"
    ],
    "edits_original": "< select > add mpg </ select > < select > remove maximum mpg </ select > < where > add cylinders equals 8 or year less than 1980 </ where > < where > remove cylinders greater than 8 or year greater than 1980 </ where > < orderBy > add mpg </ orderBy > < orderBy > add descending </ orderBy > < limit > add 1 </ limit >"
  },
  {
    "question": "What is the maximum mpg of the cars that had 8 cylinders or that were produced before 1980?",
    "db_id": "car_1",
    "gold_parse": "SELECT mpg FROM CARS_DATA WHERE Cylinders  =  8 OR YEAR  <  1980 ORDER BY mpg DESC LIMIT 1",
    "feedback": "Substitute 1 with 8 and 8 with 1980.",
    "predicted_parse_with_values": "select max ( MPG ) from cars_data where Cylinders > 1 or Year < 8",
    "template_feedback": "consider the year less than 1980 or cylinders equals 8 conditions in place of the cylinders greater than 1 or year less than 8 conditions . find mpg in place of maximum mpg . find the result with the largest mpg .",
    "predicted_parse_explanation": [
      "find the maximum mpg in cars data table whose cylinders greater than 1 or year less than 8"
    ],
    "primary_span": [
      [
        0,
        10
      ],
      [
        26,
        27
      ],
      [
        34,
        41
      ]
    ],
    "secondary_span": [
      [
        11,
        25
      ],
      [
        28,
        33
      ]
    ],
    "edits": [
      "mpg",
      "maximum mpg",
      "cylinders equals 8 or year less than 1980",
      "cylinders greater than 1 or year less than 8",
      "mpg",
      "descending",
      "1"
    ],
    "edits_original": "< select > add mpg </ select > < select > remove maximum mpg </ select > < where > add cylinders equals 8 or year less than 1980 </ where > < where > remove cylinders greater than 1 or year less than 8 </ where > < orderBy > add mpg </ orderBy > < orderBy > add descending </ orderBy > < limit > add 1 </ limit >"
  },
  {
    "question": "What are the different models wthat are lighter than 3500 but were not built by the Ford Motor Company?",
    "db_id": "car_1",
    "gold_parse": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company'",
    "feedback": "Find unique model whose weight is less than 3500 and not manufactured by the Ford Motor Company .",
    "predicted_parse_with_values": "select T3.ModelId from cars_data as T1 join car_names as T2 on T1.Id = T2.MakeId join model_list as T3 on T2.Model = T3.Model where T3.Model = 3500 and T1.Horsepower != \"Ford Motor Company\"",
    "template_feedback": "in step 1 , additionally use the information from the car makers table . in step 2 , consider the full name not equals Ford Motor Company and weight less than 3500 conditions in place of the model list 's model equals 3500 and horsepower not equals Ford Motor Company conditions . find model list 's model in place of model id . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "Step 1: for each row in cars data table , find the corresponding rows in car names table and in model list table",
      "Step 2: find the model id of the results of step 1 whose model list 's model equals 3500 and horsepower not equals Ford Motor Company"
    ],
    "primary_span": [
      [
        4,
        13
      ],
      [
        18,
        32
      ],
      [
        52,
        56
      ],
      [
        63,
        70
      ]
    ],
    "secondary_span": [
      [
        33,
        51
      ],
      [
        57,
        62
      ]
    ],
    "edits": [
      "distinct",
      "model",
      "model id",
      "car makers",
      "weight less than 3500",
      "full name not equals to \"Ford Motor Company\"",
      "model equals 3500",
      "horsepower not equals to \"Ford Motor Company\""
    ],
    "edits_original": "< select > add distinct </ select > < select > add model </ select > < select > remove model id </ select > < from > add car makers </ from > < where > add weight less than 3500 </ where > < where > add full name not equals to \" Ford Motor Company \" </ where > < where > remove model equals 3500 </ where > < where > remove horsepower not equals to \" Ford Motor Company \" </ where >"
  },
  {
    "question": "What are the ids and names of all countries that either have more than 3 car makers or produce fiats?",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.countryId ,  T1.CountryName FROM Countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.countryId HAVING count(*)  >  3 UNION SELECT T1.countryId ,  T1.CountryName FROM Countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country JOIN MODEL_LIST AS T3 ON T2.Id  =  T3.Maker WHERE T3.Model  =  'fiat'",
    "feedback": "find country id , country name who have greater than 3 car manufacturer or have made fiats .",
    "predicted_parse_with_values": "select T2.CountryId , T2.CountryName from car_makers as T1 join countries as T2 on T1.Country = T2.CountryId where T1.Maker = 3 union select T4.CountryId , T4.CountryName from car_makers as T3 join countries as T4 on T3.Country = T4.CountryId where T3.Maker = \"fiats\" group by T4.CountryId having count ( * ) > 3",
    "template_feedback": "in step 2 , remove the maker equals 3 conditions . find for each value of country id whose number of rows greater than 3 . in step 3 , additionally use the information from the model list table . in step 4 , consider the model equals fiat conditions in place of the maker equals fiats conditions . in step 5 , do not find for each value of country id .",
    "predicted_parse_explanation": [
      "Step 1: for each row in car makers table , find the corresponding rows in countries table",
      "Step 2: find the country id and country name of the results of step 1 whose maker equals 3",
      "Step 3: for each row in car makers table , find the corresponding rows in countries table",
      "Step 4: only keep the results of step 3 whose maker equals fiats",
      "Step 5: find the number of rows of each value of country id the results of step 4",
      "Step 6: find the country id and country name the results of step 4 whose corresponding value in step 5 is greater than 3",
      "Step 7: show the rows that are in any of the results of step 2 and step 6"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        11,
        25
      ],
      [
        30,
        39
      ],
      [
        44,
        49
      ],
      [
        63,
        72
      ]
    ],
    "secondary_span": [
      [
        50,
        58
      ]
    ],
    "edits": [
      "maker equals 3",
      "country id",
      "number of rows greater than 3",
      "model list",
      "model equals \"fiat\"",
      "maker equals \"fiats\"",
      "country id",
      "number of rows greater than 3"
    ],
    "edits_original": "< where > remove maker equals 3 </ where > < groupBy > add country id </ groupBy > < having > add number of rows greater than 3 </ having > < from > add model list </ from > < where > add model equals \" fiat \" </ where > < where > remove maker equals \" fiats \" </ where > < groupBy > remove country id </ groupBy > < having > remove number of rows greater than 3 </ having >"
  },
  {
    "question": "What is the airport name for airport 'AKO'?",
    "db_id": "flight_2",
    "gold_parse": "SELECT AirportName FROM AIRPORTS WHERE AirportCode  =  \"AKO\"",
    "feedback": "Swap country with airport code .",
    "predicted_parse_with_values": "select AirportName from airports where Country = \"AKO\"",
    "template_feedback": "consider the airport code equals AKO conditions in place of the country equals AKO conditions .",
    "predicted_parse_explanation": [
      "find the airport name in airports table whose country equals AKO"
    ],
    "primary_span": [
      [
        0,
        6
      ]
    ],
    "secondary_span": [
      [
        7,
        15
      ]
    ],
    "edits": [
      "airport code equals \"AKO\"",
      "country equals \"AKO\""
    ],
    "edits_original": "< where > add airport code equals \" AKO \" </ where > < where > remove country equals \" AKO \" </ where >"
  },
  {
    "question": "How many flights does airline 'JetBlue Airways' have?",
    "db_id": "flight_2",
    "gold_parse": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = \"JetBlue Airways\"",
    "feedback": "Put flights table in place of airlines table . Ensure correspondence .",
    "predicted_parse_with_values": "select count ( * ) from airlines where Airline = \"JetBlue Airways\"",
    "template_feedback": "additionally use the information from the flights table besides the airlines table .",
    "predicted_parse_explanation": [
      "find the number of rows in airlines table whose airline name equals JetBlue Airways"
    ],
    "primary_span": [
      [
        0,
        7
      ]
    ],
    "secondary_span": [
      [
        8,
        12
      ]
    ],
    "edits": [
      "flights"
    ],
    "edits_original": "< from > add flights </ from >"
  },
  {
    "question": "Give the number of Jetblue Airways flights.",
    "db_id": "flight_2",
    "gold_parse": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = \"JetBlue Airways\"",
    "feedback": "Swap airlines table with flights table . Ensure airlines 's airlines equals JetBlue Airways .",
    "predicted_parse_with_values": "select count ( * ) from airlines where Airline = \"JetBlue Airways\"",
    "template_feedback": "additionally use the information from the flights table besides the airlines table .",
    "predicted_parse_explanation": [
      "find the number of rows in airlines table whose airline name equals JetBlue Airways"
    ],
    "primary_span": [
      [
        0,
        7
      ]
    ],
    "secondary_span": [
      [
        8,
        12
      ]
    ],
    "edits": [
      "flights"
    ],
    "edits_original": "< from > add flights </ from >"
  },
  {
    "question": "How many 'United Airlines' flights go to Airport 'ASY'?",
    "db_id": "flight_2",
    "gold_parse": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.DestAirport  =  \"ASY\"",
    "feedback": "Find the number of flights of United airlines whose destination airport equals  'ASY",
    "predicted_parse_with_values": "select count ( * ) from airports where AirportName = \"ASY\"",
    "template_feedback": "use flights table and airlines table in place of airports table . consider the destination airport equals ASY and airlines 's airline name equals United Airlines conditions in place of the airport name equals ASY conditions .",
    "predicted_parse_explanation": [
      "find the number of rows in airports table whose airport name equals ASY"
    ],
    "primary_span": [
      [
        0,
        5
      ],
      [
        12,
        26
      ]
    ],
    "secondary_span": [
      [
        6,
        11
      ],
      [
        27,
        36
      ]
    ],
    "edits": [
      "airlines",
      "flights",
      "airports",
      "airline name equals \"United Airlines\"",
      "destination airport equals \"ASY\"",
      "airport name equals \"ASY\""
    ],
    "edits_original": "< from > add airlines </ from > < from > add flights </ from > < from > remove airports </ from > < where > add airline name equals \" United Airlines \" </ where > < where > add destination airport equals \" ASY \" </ where > < where > remove airport name equals \" ASY \" </ where >"
  },
  {
    "question": "Count the number of United Airlines flights arriving in ASY Airport.",
    "db_id": "flight_2",
    "gold_parse": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.DestAirport  =  \"ASY\"",
    "feedback": "Find count of flights corresponding to United airlines whose flights 's source airport equals ASY .",
    "predicted_parse_with_values": "select count ( * ) from airports where AirportName = \"ASY\"",
    "template_feedback": "use flights table and airlines table in place of airports table . consider the destination airport equals ASY and airlines 's airline name equals United Airlines conditions in place of the airport name equals ASY conditions .",
    "predicted_parse_explanation": [
      "find the number of rows in airports table whose airport name equals ASY"
    ],
    "primary_span": [
      [
        0,
        5
      ],
      [
        12,
        26
      ]
    ],
    "secondary_span": [
      [
        6,
        11
      ],
      [
        27,
        36
      ]
    ],
    "edits": [
      "airlines",
      "flights",
      "airports",
      "airline name equals \"United Airlines\"",
      "destination airport equals \"ASY\"",
      "airport name equals \"ASY\""
    ],
    "edits_original": "< from > add airlines </ from > < from > add flights </ from > < from > remove airports </ from > < where > add airline name equals \" United Airlines \" </ where > < where > add destination airport equals \" ASY \" </ where > < where > remove airport name equals \" ASY \" </ where >"
  },
  {
    "question": "How many United Airlines flights go to City 'Aberdeen'?",
    "db_id": "flight_2",
    "gold_parse": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRLINES AS T3 ON T3.uid  =  T1.Airline WHERE T2.City  =  \"Aberdeen\" AND T3.Airline  =  \"United Airlines\"",
    "feedback": "Count the flights of United airlines whose destination city equals Aberdeen .",
    "predicted_parse_with_values": "select count ( * ) from airports where City = \"Aberdeen\"",
    "template_feedback": "additionally use the information from the flights table and airlines table besides the airports table . additionally make sure that airlines 's airline name equals United Airlines .",
    "predicted_parse_explanation": [
      "find the number of rows in airports table whose city equals Aberdeen"
    ],
    "primary_span": [
      [
        0,
        10
      ],
      [
        16,
        27
      ]
    ],
    "secondary_span": [
      [
        11,
        15
      ]
    ],
    "edits": [
      "flights",
      "airlines",
      "airline name equals \"United Airlines\""
    ],
    "edits_original": "< from > add flights </ from > < from > add airlines </ from > < where > add airline name equals \" United Airlines \" </ where >"
  },
  {
    "question": "Count the number of United Airlines flights that arrive in Aberdeen.",
    "db_id": "flight_2",
    "gold_parse": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRLINES AS T3 ON T3.uid  =  T1.Airline WHERE T2.City  =  \"Aberdeen\" AND T3.Airline  =  \"United Airlines\"",
    "feedback": "Count the number of flights of United airlines whose destination city equals Aberdeen .",
    "predicted_parse_with_values": "select count ( * ) from airports where City = \"Aberdeen\"",
    "template_feedback": "additionally use the information from the flights table and airlines table besides the airports table . additionally make sure that airlines 's airline name equals United Airlines .",
    "predicted_parse_explanation": [
      "find the number of rows in airports table whose city equals Aberdeen"
    ],
    "primary_span": [
      [
        0,
        10
      ],
      [
        16,
        27
      ]
    ],
    "secondary_span": [
      [
        11,
        15
      ]
    ],
    "edits": [
      "flights",
      "airlines",
      "airline name equals \"United Airlines\""
    ],
    "edits_original": "< from > add flights </ from > < from > add airlines </ from > < where > add airline name equals \" United Airlines \" </ where >"
  },
  {
    "question": "Which city is the most frequent source airport?",
    "db_id": "flight_2",
    "gold_parse": "SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.SourceAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1",
    "feedback": "Change city in airports table with source airport in flights in step 1.",
    "predicted_parse_with_values": "select City from airports group by City order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the flights table besides the airports table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of city in airports table",
      "Step 2: find the city in airports table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "flights"
    ],
    "edits_original": "< from > add flights </ from >"
  },
  {
    "question": "What is the airport code of the airport with the most flights?",
    "db_id": "flight_2",
    "gold_parse": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1",
    "feedback": "Find airport code of airports table whose corresponding count for flights is largest .",
    "predicted_parse_with_values": "select AirportCode from airports group by AirportCode order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the flights table besides the airports table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of airport code in airports table",
      "Step 2: find the airport code in airports table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "flights"
    ],
    "edits_original": "< from > add flights </ from >"
  },
  {
    "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?",
    "db_id": "flight_2",
    "gold_parse": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1",
    "feedback": "Step 2 , Find Number of rows for airlines in flights instead of smallest value of flight number .",
    "predicted_parse_with_values": "select T2.Abbreviation , T2.Country from flights as T1 join airlines as T2 order by T1.FlightNo limit 1",
    "template_feedback": "in step 2 , find for each value of airlines 's airline name . order the results by number of rows in place of flight number .",
    "predicted_parse_explanation": [
      "Step 1: for each row in flights table , find the corresponding rows in airlines table",
      "Step 2: find the abbreviation and country of the results of step 1 with smallest value of flight number"
    ],
    "primary_span": [
      [
        4,
        13
      ],
      [
        14,
        20
      ]
    ],
    "secondary_span": [
      [
        21,
        26
      ]
    ],
    "edits": [
      "airline name",
      "number of rows",
      "flight number"
    ],
    "edits_original": "< groupBy > add airline name </ groupBy > < orderBy > add number of rows </ orderBy > < orderBy > remove flight number </ orderBy >"
  },
  {
    "question": "What are airlines that have some flight departing from airport 'AHD'?",
    "db_id": "flight_2",
    "gold_parse": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"AHD\"",
    "feedback": "Swap flight number with destination airport in step 2.",
    "predicted_parse_with_values": "select T2.Airline from flights as T1 join airlines as T2 where T1.FlightNo = \"AHD\"",
    "template_feedback": "in step 2 , consider the source airport equals AHD conditions in place of the flight number equals AHD conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in flights table , find the corresponding rows in airlines table",
      "Step 2: find the airlines 's airline name of the results of step 1 whose flight number equals AHD"
    ],
    "primary_span": [
      [
        4,
        10
      ]
    ],
    "secondary_span": [
      [
        11,
        20
      ]
    ],
    "edits": [
      "source airport equals \"AHD\"",
      "flight number equals \"AHD\""
    ],
    "edits_original": "< where > add source airport equals \" AHD \" </ where > < where > remove flight number equals \" AHD \" </ where >"
  },
  {
    "question": "Which airlines have a flight with destination airport AHD?",
    "db_id": "flight_2",
    "gold_parse": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.DestAirport  =  \"AHD\"",
    "feedback": "Swap flights table with airlines table and Corresponding destination airport equals AHD .",
    "predicted_parse_with_values": "select Airline from flights where DestAirport = \"AHD\"",
    "template_feedback": "additionally use the information from the airlines table besides the flights table . find airlines 's airline name in place of flights 's airline .",
    "predicted_parse_explanation": [
      "find the airline in flights table whose destination airport equals AHD"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        13,
        17
      ]
    ],
    "secondary_span": [
      [
        8,
        12
      ],
      [
        18,
        24
      ]
    ],
    "edits": [
      "airline name",
      "airline",
      "airlines"
    ],
    "edits_original": "< select > add airline name </ select > < select > remove airline </ select > < from > add airlines </ from >"
  },
  {
    "question": "Find all airlines that have flights from airport 'CVO' but not from 'APG'.",
    "db_id": "flight_2",
    "gold_parse": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\" EXCEPT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\"",
    "feedback": "In Step 2 and Step 3 Replace airport name with source airport .",
    "predicted_parse_with_values": "select T1.Airline from flights as T1 join airports as T2 on T1.DestAirport = T2.AirportCode where T2.AirportName = \"CVO\" except select T3.Airline from flights as T3 join airports as T4 on T3.DestAirport = T4.AirportCode where T4.AirportName = \"APG\"",
    "template_feedback": "in step 1 , use airlines table in place of airports table in step 2 , consider the source airport equals CVO conditions in place of the airport name equals CVO conditions . find airlines 's airline name in place of flights 's airline . in step 3 , use airlines table in place of airports table in step 4 , consider the source airport equals APG conditions in place of the airport name equals APG conditions . find airlines 's airline name in place of flights 's airline .",
    "predicted_parse_explanation": [
      "Step 1: for each row in flights table , find the corresponding rows in airports table",
      "Step 2: find the airline of the results of step 1 whose airport name equals CVO",
      "Step 3: for each row in flights table , find the corresponding rows in airports table",
      "Step 4: find the airline of the results of step 3 whose airport name equals APG",
      "Step 5: show the rows that are in the results of step 2 but not in the results of step 4"
    ],
    "primary_span": [
      [
        4,
        6
      ],
      [
        16,
        22
      ],
      [
        33,
        37
      ],
      [
        49,
        51
      ],
      [
        61,
        67
      ],
      [
        78,
        82
      ]
    ],
    "secondary_span": [
      [
        7,
        11
      ],
      [
        23,
        32
      ],
      [
        38,
        44
      ],
      [
        52,
        56
      ],
      [
        68,
        77
      ],
      [
        83,
        89
      ]
    ],
    "edits": [
      "airline name",
      "airline",
      "airlines",
      "airports",
      "source airport equals \"CVO\"",
      "airport name equals \"CVO\"",
      "airline name",
      "airline",
      "airlines",
      "airports",
      "source airport equals \"APG\"",
      "airport name equals \"APG\""
    ],
    "edits_original": "< select > add airline name </ select > < select > remove airline </ select > < from > add airlines </ from > < from > remove airports </ from > < where > add source airport equals \" CVO \" </ where > < where > remove airport name equals \" CVO \" </ where > < select > add airline name </ select > < select > remove airline </ select > < from > add airlines </ from > < from > remove airports </ from > < where > add source airport equals \" APG \" </ where > < where > remove airport name equals \" APG \" </ where >"
  },
  {
    "question": "Find all airlines that have at least 10 flights.",
    "db_id": "flight_2",
    "gold_parse": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10",
    "feedback": "In Step 2 , Change airlines in flights table with airlines in airlines table .",
    "predicted_parse_with_values": "select Airline from flights group by Airline having count ( * ) > = 10",
    "template_feedback": "in step 1 , additionally use the information from the airlines table besides the flights table . find for each value of airlines 's airline name whose number of rows greater than 10 . in step 2 , find airlines 's airline name in place of flights 's airline .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of airline in flights table",
      "Step 2: find the airline in flights table whose corresponding value in step 1 is greater than or equals 10"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        17,
        33
      ],
      [
        38,
        42
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ],
      [
        43,
        49
      ]
    ],
    "edits": [
      "airline name",
      "airline",
      "airlines",
      "airline name",
      "airline",
      "number of rows greater than 10",
      "number of rows greater than or equals to 10"
    ],
    "edits_original": "< select > add airline name </ select > < select > remove airline </ select > < from > add airlines </ from > < groupBy > add airline name </ groupBy > < groupBy > remove airline </ groupBy > < having > add number of rows greater than 10 </ having > < having > remove number of rows greater than or equals to 10 </ having >"
  },
  {
    "question": "What are flight numbers of flights arriving at Airport \"APG\"?",
    "db_id": "flight_2",
    "gold_parse": "SELECT FlightNo FROM FLIGHTS WHERE DestAirport  =  \"APG\"",
    "feedback": "Replace airport name with destination airport in step 2.",
    "predicted_parse_with_values": "select T1.FlightNo from flights as T1 join airports as T2 on T1.DestAirport = T2.AirportCode where T2.AirportName = \"APG\"",
    "template_feedback": "in step 1 , do not use the airports table . in step 2 , consider the destination airport equals APG conditions in place of the airport name equals APG conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in flights table , find the corresponding rows in airports table",
      "Step 2: find the flight number of the results of step 1 whose airport name equals APG"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        21
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        22,
        31
      ]
    ],
    "edits": [
      "airports",
      "destination airport equals \"APG\"",
      "airport name equals \"APG\""
    ],
    "edits_original": "< from > remove airports </ from > < where > add destination airport equals \" APG \" </ where > < where > remove airport name equals \" APG \" </ where >"
  },
  {
    "question": "How many flights land in Aberdeen or Abilene?",
    "db_id": "flight_2",
    "gold_parse": "SELECT count(*) FROM Flights AS T1 JOIN Airports AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.city  =  \"Aberdeen\" OR T2.city  =  \"Abilene\"",
    "feedback": "In Step 2 , Find Number of rows whose destination airport code is of city Aberdeen or Abilene .",
    "predicted_parse_with_values": "select count ( * ) from flights as T1 join airports as T2 on T1.DestAirport = T2.AirportCode where T2.AirportName = \"Aberdeen\" or T2.AirportName = \"Abilene\"",
    "template_feedback": "in step 2 , consider the city equals Aberdeen or city equals Abilene conditions in place of the airport name equals Aberdeen or airport name equals Abilene conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in flights table , find the corresponding rows in airports table",
      "Step 2: find the number of rows of the results of step 1 whose airport name equals Aberdeen or airport name equals Abilene"
    ],
    "primary_span": [
      [
        4,
        13
      ]
    ],
    "secondary_span": [
      [
        14,
        28
      ]
    ],
    "edits": [
      "city equals \"Aberdeen\" or city equals \"Abilene\"",
      "airport name equals \"Aberdeen\" or airport name equals \"Abilene\""
    ],
    "edits_original": "< where > add city equals \" Aberdeen \" or city equals \" Abilene \" </ where > < where > remove airport name equals \" Aberdeen \" or airport name equals \" Abilene \" </ where >"
  },
  {
    "question": "Find the number of employees hired in each shop; show the shop name as well.",
    "db_id": "employee_hire_evaluation",
    "gold_parse": "SELECT count(*) ,  t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t2.name",
    "feedback": "Add hiring 's shop id ahead of \"each value\" at end .",
    "predicted_parse_with_values": "select count ( * ) , Name from shop group by Name",
    "template_feedback": "additionally use the information from the hiring table besides the shop table .",
    "predicted_parse_explanation": [
      "find each value of name in shop table along with the number of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        0,
        7
      ]
    ],
    "secondary_span": [
      [
        8,
        12
      ]
    ],
    "edits": [
      "hiring"
    ],
    "edits_original": "< from > add hiring </ from >"
  },
  {
    "question": "For each shop, return the number of employees working there and the name of the shop.",
    "db_id": "employee_hire_evaluation",
    "gold_parse": "SELECT count(*) ,  t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t2.name",
    "feedback": "Find shop id in hiring table with Count of employee id and Corresponding name from shop table .",
    "predicted_parse_with_values": "select Name , count ( * ) from shop group by Shop_ID",
    "template_feedback": "additionally use the information from the hiring table besides the shop table . find for each value of name in place of shop 's shop id .",
    "predicted_parse_explanation": [
      "find each value of shop id in shop table along with the number of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        13,
        18
      ]
    ],
    "secondary_span": [
      [
        8,
        12
      ],
      [
        19,
        26
      ]
    ],
    "edits": [
      "hiring",
      "name",
      "shop id"
    ],
    "edits_original": "< from > add hiring </ from > < groupBy > add name </ groupBy > < groupBy > remove shop id </ groupBy >"
  },
  {
    "question": "What the smallest version number and its template type code?",
    "db_id": "cre_Doc_Template_Mgt",
    "gold_parse": "SELECT min(Version_Number) ,  template_type_code FROM Templates",
    "feedback": "Switch second template type code with version number .",
    "predicted_parse_with_values": "select Version_Number , Template_Type_Code from Templates order by Template_Type_Code asc limit 1",
    "template_feedback": "find minimum version number in place of version number . you should not find the smallest of the results . show me all the results .",
    "predicted_parse_explanation": [
      "find the version number and template type code in templates table with smallest value of template type code"
    ],
    "primary_span": [
      [
        0,
        3
      ],
      [
        10,
        25
      ]
    ],
    "secondary_span": [
      [
        4,
        9
      ]
    ],
    "edits": [
      "minimum version number",
      "version number",
      "template type code",
      "1"
    ],
    "edits_original": "< select > add minimum version number </ select > < select > remove version number </ select > < orderBy > remove template type code </ orderBy > < limit > remove 1 </ limit >"
  },
  {
    "question": "Show all template type codes that are not used by any document.",
    "db_id": "cre_Doc_Template_Mgt",
    "gold_parse": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id",
    "feedback": "In Step 2 Swap templates Table\" with documents Table\" and Ensure correspondence .",
    "predicted_parse_with_values": "select Template_Type_Code from Templates except select Template_Type_Code from Templates",
    "template_feedback": "in step 2 , additionally use the information from the documents table besides the templates table .",
    "predicted_parse_explanation": [
      "Step 1: find the template type code in templates table",
      "Step 2: find the template type code in templates table",
      "Step 3: show the rows that are in the results of step 1 but not in the results of step 2"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "documents"
    ],
    "edits_original": "< from > add documents </ from >"
  },
  {
    "question": "What are the codes of template types that are not used for any document?",
    "db_id": "cre_Doc_Template_Mgt",
    "gold_parse": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id",
    "feedback": "There should be documents table in place of templates table in step 2.",
    "predicted_parse_with_values": "select Template_Type_Code from Templates except select Template_Type_Code from Templates",
    "template_feedback": "in step 2 , additionally use the information from the documents table besides the templates table .",
    "predicted_parse_explanation": [
      "Step 1: find the template type code in templates table",
      "Step 2: find the template type code in templates table",
      "Step 3: show the rows that are in the results of step 1 but not in the results of step 2"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "documents"
    ],
    "edits_original": "< from > add documents </ from >"
  },
  {
    "question": "Return the different descriptions for templates that have been used in a document.",
    "db_id": "cre_Doc_Template_Mgt",
    "gold_parse": "SELECT DISTINCT T1.template_type_description FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code JOIN Documents AS T3 ON T2.Template_ID  =  T3.template_ID",
    "feedback": "Find without repetition reference template types 's template type description whose corresponding template type code 's template id present under documents table .",
    "predicted_parse_with_values": "select Document_Description from Documents",
    "template_feedback": "additionally use the information from the templates table and reference template types table besides the documents table . find template type description in place of document description . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "find the document description in documents table"
    ],
    "primary_span": [
      [
        0,
        12
      ],
      [
        18,
        21
      ],
      [
        28,
        35
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ],
      [
        22,
        27
      ]
    ],
    "edits": [
      "distinct",
      "template type description",
      "document description",
      "reference template types",
      "templates"
    ],
    "edits_original": "< select > add distinct </ select > < select > add template type description </ select > < select > remove document description </ select > < from > add reference template types </ from > < from > add templates </ from >"
  },
  {
    "question": "Return the different document ids along with the number of paragraphs corresponding to each, ordered by id.",
    "db_id": "cre_Doc_Template_Mgt",
    "gold_parse": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id",
    "feedback": "Instead of \"ordered ascending by the results of step 1\" Use \"order ascending by document id . \"",
    "predicted_parse_with_values": "select Document_ID , count ( * ) from Paragraphs group by Document_ID order by count ( * ) asc",
    "template_feedback": "in step 2 , order the results by document id in place of number of rows .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of document id in paragraphs table",
      "Step 2: find the document id and number of rows in paragraphs table ordered ascending by the results of step 1"
    ],
    "primary_span": [
      [
        4,
        9
      ]
    ],
    "secondary_span": [
      [
        10,
        16
      ]
    ],
    "edits": [
      "document id",
      "number of rows"
    ],
    "edits_original": "< orderBy > add document id </ orderBy > < orderBy > remove number of rows </ orderBy >"
  },
  {
    "question": "Return the id and name of the document with the most paragraphs.",
    "db_id": "cre_Doc_Template_Mgt",
    "gold_parse": "SELECT T1.document_id ,  T2.document_name FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ORDER BY count(*) DESC LIMIT 1",
    "feedback": "In Step 1 Put paragraphs table in place of documents table .",
    "predicted_parse_with_values": "select Document_ID , Document_Name from Documents group by Document_ID order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the paragraphs table besides the documents table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of document id in documents table",
      "Step 2: find the document id and document name in documents table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "paragraphs"
    ],
    "edits_original": "< from > add paragraphs </ from >"
  },
  {
    "question": "Return the id of the document with the fewest paragraphs.",
    "db_id": "cre_Doc_Template_Mgt",
    "gold_parse": "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1",
    "feedback": "There should be paragraphs table in place of documents table in step 2.",
    "predicted_parse_with_values": "select T1.Document_ID from Documents as T1 join Paragraphs as T2 on T1.Document_ID = T2.Document_ID group by T1.Document_ID order by count ( * ) asc limit 1",
    "template_feedback": "in step 1 , do not use the documents table .",
    "predicted_parse_explanation": [
      "Step 1: for each row in documents table , find the corresponding rows in paragraphs table",
      "Step 2: find the number of rows of each value of documents 's document id of the results of step 1",
      "Step 3: find the documents 's document id of the results of step 1 with smallest value in the results of step 2"
    ],
    "primary_span": [
      [
        4,
        10
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ]
    ],
    "edits": [
      "documents"
    ],
    "edits_original": "< from > remove documents </ from >"
  },
  {
    "question": "What is the most commmon hometowns for teachers?",
    "db_id": "course_teach",
    "gold_parse": "SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1",
    "feedback": "Find number of corresponding rows of each value of teacher 's hometown , display hometown with highest count .",
    "predicted_parse_with_values": "select Hometown from teacher where Name = \"hometown\" group by Hometown order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , remove the name equals hometown conditions .",
    "predicted_parse_explanation": [
      "Step 1: find rows in teacher table whose name equals hometown",
      "Step 2: find the number of rows of each value of hometown the results of step 1",
      "Step 3: find the hometown the results of step 1 with largest value in the results of step 2"
    ],
    "primary_span": [
      [
        4,
        10
      ]
    ],
    "secondary_span": [],
    "edits": [
      "name equals \"hometown\""
    ],
    "edits_original": "< where > remove name equals \" hometown \" </ where >"
  },
  {
    "question": "What are the names of the teachers who teach at least two courses?",
    "db_id": "course_teach",
    "gold_parse": "SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*)  >=  2",
    "feedback": "In step 1 replace teacher table with course arrange table .",
    "predicted_parse_with_values": "select Name from teacher group by Teacher_ID having count ( * ) > = 2",
    "template_feedback": "in step 1 , additionally use the information from the course arrange table besides the teacher table . find for value of name in place of teacher 's teacher id .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of teacher id in teacher table",
      "Step 2: find the name in teacher table whose corresponding value in step 1 is greater than or equals 2"
    ],
    "primary_span": [
      [
        4,
        12
      ],
      [
        18,
        22
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ],
      [
        23,
        30
      ]
    ],
    "edits": [
      "course arrange",
      "name",
      "teacher id"
    ],
    "edits_original": "< from > add course arrange </ from > < groupBy > add name </ groupBy > < groupBy > remove teacher id </ groupBy >"
  },
  {
    "question": "Find the names of the visitors whose membership level is higher than 4, and order the results by the level from high to low.",
    "db_id": "museum_visit",
    "gold_parse": "SELECT name FROM visitor WHERE Level_of_membership  >  4 ORDER BY Level_of_membership DESC",
    "feedback": "Order Descending instead of ascending .",
    "predicted_parse_with_values": "select Name from visitor where Level_of_membership > 4 order by Level_of_membership",
    "template_feedback": "order the results descending .",
    "predicted_parse_explanation": [
      "find the name in customer table whose level of membership greater than 4 ordered ascending by level of membership"
    ],
    "primary_span": [
      [
        0,
        4
      ]
    ],
    "secondary_span": [],
    "edits": [
      "descending"
    ],
    "edits_original": "< orderBy > add descending </ orderBy >"
  },
  {
    "question": "What is the average age of the visitors whose membership level is not higher than 4?",
    "db_id": "museum_visit",
    "gold_parse": "SELECT avg(age) FROM visitor WHERE Level_of_membership  <=  4",
    "feedback": "Ensure that level of membership is not greater than 4.",
    "predicted_parse_with_values": "select avg ( Age ) from visitor where Level_of_membership > 4",
    "template_feedback": "consider the level of membership less than or equals 4 conditions in place of the level of membership greater than 4 conditions .",
    "predicted_parse_explanation": [
      "find the average age in customer table whose level of membership greater than 4"
    ],
    "primary_span": [
      [
        0,
        10
      ]
    ],
    "secondary_span": [
      [
        11,
        22
      ]
    ],
    "edits": [
      "level of membership less than or equals to 4",
      "level of membership greater than 4"
    ],
    "edits_original": "< where > add level of membership less than or equals to 4 </ where > < where > remove level of membership greater than 4 </ where >"
  },
  {
    "question": "Find the name and membership level of the visitors whose membership level is higher than 4, and sort by their age from old to young.",
    "db_id": "museum_visit",
    "gold_parse": "SELECT name ,  Level_of_membership FROM visitor WHERE Level_of_membership  >  4 ORDER BY age DESC",
    "feedback": "Use level of membership instead of age and ensure ordered descending by age .",
    "predicted_parse_with_values": "select Name , Level_of_membership from visitor where Age > 4 order by Level_of_membership",
    "template_feedback": "consider the level of membership greater than 4 conditions in place of the age greater than 4 conditions . order the results descending by age in place of ordering ascending by level of membership .",
    "predicted_parse_explanation": [
      "find the name and level of membership in customer table whose age greater than 4 ordered ascending by level of membership"
    ],
    "primary_span": [
      [
        0,
        8
      ],
      [
        19,
        24
      ]
    ],
    "secondary_span": [
      [
        9,
        18
      ],
      [
        25,
        34
      ]
    ],
    "edits": [
      "level of membership greater than 4",
      "age greater than 4",
      "age",
      "descending",
      "level of membership"
    ],
    "edits_original": "< where > add level of membership greater than 4 </ where > < where > remove age greater than 4 </ where > < orderBy > add age </ orderBy > < orderBy > add descending </ orderBy > < orderBy > remove level of membership </ orderBy >"
  },
  {
    "question": "What are the names of players who won in both 2013 and 2016?",
    "db_id": "wta_1",
    "gold_parse": "SELECT winner_name FROM matches WHERE YEAR  =  2013 INTERSECT SELECT winner_name FROM matches WHERE YEAR  =  2016",
    "feedback": "In Step 2 hand Step 3 Replace first name with winner age .",
    "predicted_parse_with_values": "select T2.first_name from matches as T1 join players as T2 on T1.winner_id = T2.player_id where T1.year = 2013 intersect select T4.first_name from matches as T3 join players as T4 on T3.winner_id = T4.player_id where T3.year = 2016",
    "template_feedback": "in step 1 , do not use the players table . in step 2 , find winner name in place of first name . in step 3 , do not use the players table . in step 4 , find winner name in place of first name .",
    "predicted_parse_explanation": [
      "Step 1: for each row in matches table , find the corresponding rows in players table",
      "Step 2: find the first name of the results of step 1 whose year equals 2013",
      "Step 3: for each row in matches table , find the corresponding rows in players table",
      "Step 4: find the first name of the results of step 3 whose year equals 2016",
      "Step 5: show the rows that are in both the results of step 2 and step 4"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        17
      ],
      [
        28,
        34
      ],
      [
        39,
        41
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        18,
        23
      ],
      [
        28,
        34
      ],
      [
        42,
        47
      ]
    ],
    "edits": [
      "winner name",
      "first name",
      "players",
      "winner name",
      "first name",
      "players"
    ],
    "edits_original": "< select > add winner name </ select > < select > remove first name </ select > < from > remove players </ from > < select > add winner name </ select > < select > remove first name </ select > < from > remove players </ from >"
  },
  {
    "question": "Find the first name and country code of the oldest player.",
    "db_id": "wta_1",
    "gold_parse": "SELECT first_name ,  country_code FROM players ORDER BY birth_date LIMIT 1",
    "feedback": "Swap \"largest\" with \"smallest\".",
    "predicted_parse_with_values": "select first_name , country_code from players order by birth_date desc limit 1",
    "template_feedback": "use the smallest in place of largest .",
    "predicted_parse_explanation": [
      "find the first name and country code in players table with largest value of birth date"
    ],
    "primary_span": [
      [
        0,
        2
      ]
    ],
    "secondary_span": [
      [
        3,
        7
      ]
    ],
    "edits": [
      "descending"
    ],
    "edits_original": "< orderBy > remove descending </ orderBy >"
  },
  {
    "question": "What is the first name and country code of the oldest player?",
    "db_id": "wta_1",
    "gold_parse": "SELECT first_name ,  country_code FROM players ORDER BY birth_date LIMIT 1",
    "feedback": "Interchange \"largest\" with \"smallest\".",
    "predicted_parse_with_values": "select first_name , country_code from players order by birth_date desc limit 1",
    "template_feedback": "use the smallest in place of largest .",
    "predicted_parse_explanation": [
      "find the first name and country code in players table with largest value of birth date"
    ],
    "primary_span": [
      [
        0,
        2
      ]
    ],
    "secondary_span": [
      [
        3,
        7
      ]
    ],
    "edits": [
      "descending"
    ],
    "edits_original": "< orderBy > remove descending </ orderBy >"
  },
  {
    "question": "List the first and last name of all players who are left / L hand in the order of birth date.",
    "db_id": "wta_1",
    "gold_parse": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date",
    "feedback": "In Step 2 find last name also , Swap winner hand with hand .",
    "predicted_parse_with_values": "select T2.first_name , T2.last_name from matches as T1 join players as T2 on T1.winner_id = T2.player_id where T1.winner_hand = \"L\" order by T2.birth_date",
    "template_feedback": "in step 1 , do not use the matches table . in step 2 , consider the hand equals L conditions in place of the winner hand equals L conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in matches table , find the corresponding rows in players table",
      "Step 2: find the first name and last name of the results of step 1 whose winner hand equals L ordered ascending by birth date"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        20
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        21,
        30
      ]
    ],
    "edits": [
      "matches",
      "hand equals \"L\"",
      "winner hand equals \"L\""
    ],
    "edits_original": "< from > remove matches </ from > < where > add hand equals \" L \" </ where > < where > remove winner hand equals \" L \" </ where >"
  },
  {
    "question": "Find the first name and country code of the player who did the most number of tours.",
    "db_id": "wta_1",
    "gold_parse": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT 1",
    "feedback": "Replace country code in players table with player id in rankings table in step 1.",
    "predicted_parse_with_values": "select first_name , country_code from players group by country_code order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the rankings table besides the players table . do not find for each value of country code . in step 2 , order the results by tours in place of number of rows .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of country code in players table",
      "Step 2: find the first name and country code in players table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        17,
        26
      ],
      [
        31,
        35
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ],
      [
        36,
        42
      ]
    ],
    "edits": [
      "rankings",
      "country code",
      "tours",
      "number of rows"
    ],
    "edits_original": "< from > add rankings </ from > < groupBy > remove country code </ groupBy > < orderBy > add tours </ orderBy > < orderBy > remove number of rows </ orderBy >"
  },
  {
    "question": "Find the name and rank points of the winner who won the most times.",
    "db_id": "wta_1",
    "gold_parse": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1",
    "feedback": "There should be winner rank points instead of winner rank .",
    "predicted_parse_with_values": "select winner_name , winner_rank from matches group by winner_id order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , find for each value of winner name in place of winner id . in step 2 , find winner rank points in place of winner rank .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of winner id in matches table",
      "Step 2: find the winner name and winner rank in matches table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        21,
        24
      ]
    ],
    "secondary_span": [
      [
        11,
        16
      ],
      [
        25,
        30
      ]
    ],
    "edits": [
      "winner rank points",
      "winner rank",
      "winner name",
      "winner id"
    ],
    "edits_original": "< select > add winner rank points </ select > < select > remove winner rank </ select > < groupBy > add winner name </ groupBy > < groupBy > remove winner id </ groupBy >"
  },
  {
    "question": "Find the name of the winner who has the highest rank points and participated in the Australian Open tourney.",
    "db_id": "wta_1",
    "gold_parse": "SELECT winner_name FROM matches WHERE tourney_name  =  'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1",
    "feedback": "Exchange winner rank with tourney name .",
    "predicted_parse_with_values": "select winner_name from matches where winner_rank = \"Australian Open\" order by winner_rank_points desc limit 1",
    "template_feedback": "consider the tourney name equals Australian Open conditions in place of the winner rank equals Australian Open conditions .",
    "predicted_parse_explanation": [
      "find the winner name in matches table whose winner rank equals Australian Open with largest value of winner rank points"
    ],
    "primary_span": [
      [
        0,
        7
      ]
    ],
    "secondary_span": [
      [
        8,
        18
      ]
    ],
    "edits": [
      "tourney name equals \"Australian Open\"",
      "winner rank equals \"Australian Open\""
    ],
    "edits_original": "< where > add tourney name equals \" Australian Open \" </ where > < where > remove winner rank equals \" Australian Open \" </ where >"
  },
  {
    "question": "find the names of loser and winner who played in the match with greatest number of minutes.",
    "db_id": "wta_1",
    "gold_parse": "SELECT winner_name ,  loser_name FROM matches ORDER BY minutes DESC LIMIT 1",
    "feedback": "Change winner rank with winner age .",
    "predicted_parse_with_values": "select loser_name , winner_rank from matches order by minutes desc limit 1",
    "template_feedback": "find winner name in place of winner rank .",
    "predicted_parse_explanation": [
      "find the loser name and winner rank in matches table with largest value of minutes"
    ],
    "primary_span": [
      [
        0,
        2
      ]
    ],
    "secondary_span": [
      [
        3,
        8
      ]
    ],
    "edits": [
      "winner name",
      "winner rank"
    ],
    "edits_original": "< select > add winner name </ select > < select > remove winner rank </ select >"
  },
  {
    "question": "What are the names of the winner and loser who played in the longest match?",
    "db_id": "wta_1",
    "gold_parse": "SELECT winner_name ,  loser_name FROM matches ORDER BY minutes DESC LIMIT 1",
    "feedback": "Also find loser name , hand swap year with minutes .",
    "predicted_parse_with_values": "select winner_name from matches order by year desc limit 1",
    "template_feedback": "additionally find loser name . order the results by minutes in place of year .",
    "predicted_parse_explanation": [
      "find the winner name in matches table with largest value of year"
    ],
    "primary_span": [
      [
        0,
        4
      ],
      [
        5,
        9
      ]
    ],
    "secondary_span": [
      [
        10,
        14
      ]
    ],
    "edits": [
      "loser name",
      "minutes",
      "year"
    ],
    "edits_original": "< select > add loser name </ select > < orderBy > add minutes </ orderBy > < orderBy > remove year </ orderBy >"
  },
  {
    "question": "Find the total number of tours for each ranking date.",
    "db_id": "wta_1",
    "gold_parse": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date",
    "feedback": "replace number of rows with the summation of tours",
    "predicted_parse_with_values": "select ranking_date , count ( * ) from rankings group by ranking_date",
    "template_feedback": "find summation of tours in place of number of rows .",
    "predicted_parse_explanation": [
      "find each value of ranking date in rankings table along with the number of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        0,
        3
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ]
    ],
    "edits": [
      "summation of tours",
      "number of rows"
    ],
    "edits_original": "< select > add summation of tours </ select > < select > remove number of rows </ select >"
  },
  {
    "question": "Find the number of left handed winners who participated in the WTA Championships.",
    "db_id": "wta_1",
    "gold_parse": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L'",
    "feedback": "In Step 2 Find whose winner hand equals L hand tourney name equals WTA Championships .",
    "predicted_parse_with_values": "select count ( * ) from matches as T1 join players as T2 on T1.winner_id = T2.player_id where T2.hand = \"L\" and T1.winner_age = 20",
    "template_feedback": "in step 1 , do not use the players table . in step 2 , consider the winner hand equals L and tourney name equals WTA Championships conditions in place of the winner age equals 20 and hand equals L conditions . find number of different winner name in place of number of rows .",
    "predicted_parse_explanation": [
      "Step 1: for each row in matches table , find the corresponding rows in players table",
      "Step 2: find the number of rows of the results of step 1 whose hand equals L and winner age equals 20"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        27
      ],
      [
        42,
        47
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        28,
        41
      ],
      [
        48,
        54
      ]
    ],
    "edits": [
      "number of distinct winner name",
      "number of rows",
      "players",
      "tourney name equals \"WTA Championships\"",
      "winner hand equals \"L\"",
      "hand equals \"L\"",
      "winner age equals 20"
    ],
    "edits_original": "< select > add number of distinct winner name </ select > < select > remove number of rows </ select > < from > remove players </ from > < where > add tourney name equals \" WTA Championships \" </ where > < where > add winner hand equals \" L \" </ where > < where > remove hand equals \" L \" </ where > < where > remove winner age equals 20 </ where >"
  },
  {
    "question": "Find the first name, country code and birth date of the winner who has the highest rank points in all matches.",
    "db_id": "wta_1",
    "gold_parse": "SELECT T1.first_name ,  T1.country_code ,  T1.birth_date FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id ORDER BY T2.winner_rank_points DESC LIMIT 1",
    "feedback": "Find first name , birth date in place of winner age , ranking date in step 2.",
    "predicted_parse_with_values": "select T1.winner_name , T2.country_code , T3.ranking_date from matches as T1 join players as T2 on T1.winner_id = T2.player_id join rankings as T3 on T2.player_id = T3.player_id order by T1.winner_rank_points desc limit 1",
    "template_feedback": "in step 1 , do not use the rankings table . in step 2 , find first name and birth date in place of winner name and ranking date .",
    "predicted_parse_explanation": [
      "Step 1: for each row in matches table , find the corresponding rows in players table and in rankings table",
      "Step 2: find the winner name , country code , ranking date of the results of step 1 with largest value of winner rank points"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        20
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        21,
        29
      ]
    ],
    "edits": [
      "first name",
      "birth date",
      "winner name",
      "ranking date",
      "rankings"
    ],
    "edits_original": "< select > add first name </ select > < select > add birth date </ select > < select > remove winner name </ select > < select > remove ranking date </ select > < from > remove rankings </ from >"
  },
  {
    "question": "How many ships ended up being 'Captured'?",
    "db_id": "battle_death",
    "gold_parse": "SELECT count(*) FROM ship WHERE disposition_of_ship  =  'Captured'",
    "feedback": "Swap \" result equals Captured\" with disposition of ship equals Captured\".",
    "predicted_parse_with_values": "select count ( * ) from battle as T1 join ship as T2 on T1.id = T2.lost_in_battle where T1.result = \"Captured\"",
    "template_feedback": "in step 1 , do not use the battle table . in step 2 , consider the disposition of ship equals Captured conditions in place of the result equals Captured conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in battle table , find the corresponding rows in ship table",
      "Step 2: find the number of rows of the results of step 1 whose result equals Captured"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        22
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        23,
        31
      ]
    ],
    "edits": [
      "battle",
      "disposition of ship equals \"Captured\"",
      "result equals \"Captured\""
    ],
    "edits_original": "< from > remove battle </ from > < where > add disposition of ship equals \" Captured \" </ where > < where > remove result equals \" Captured \" </ where >"
  },
  {
    "question": "What are the death and injury situations caused by the ship with tonnage 't'?",
    "db_id": "battle_death",
    "gold_parse": "SELECT T1.killed ,  T1.injured FROM death AS T1 JOIN ship AS t2 ON T1.caused_by_ship_id  =  T2.id WHERE T2.tonnage  =  't'",
    "feedback": "Also find killed along with injured in step 2.",
    "predicted_parse_with_values": "select T2.injured from ship as T1 join death as T2 on T1.id = T2.caused_by_ship_id where T1.tonnage = \"t\"",
    "template_feedback": "in step 2 , additionally find killed .",
    "predicted_parse_explanation": [
      "Step 1: for each row in ship table , find the corresponding rows in death table",
      "Step 2: find the injured of the results of step 1 whose tonnage equals t"
    ],
    "primary_span": [
      [
        4,
        7
      ]
    ],
    "secondary_span": [],
    "edits": [
      "killed"
    ],
    "edits_original": "< select > add killed </ select >"
  },
  {
    "question": "List the name and date the battle that has lost the ship named 'Lettice' and the ship named 'HMS Atalanta'",
    "db_id": "battle_death",
    "gold_parse": "SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name  =  'Lettice' INTERSECT SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name  =  'HMS Atalanta'",
    "feedback": "Change disposition of ship with ship 's name in step 2.",
    "predicted_parse_with_values": "select T1.name , T1.date from battle as T1 join ship as T2 on T1.id = T2.lost_in_battle where T2.disposition_of_ship = \"Lettice\" intersect select T3.name , T3.date from battle as T3 join ship as T4 on T3.id = T4.lost_in_battle where T4.name = \"HMS Atalanta\"",
    "template_feedback": "in step 2 , consider the ship 's name equals Lettice conditions in place of the disposition of ship equals Lettice conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in battle table , find the corresponding rows in ship table",
      "Step 2: find the battle 's name and date of the results of step 1 whose disposition of ship equals Lettice",
      "Step 3: for each row in battle table , find the corresponding rows in ship table",
      "Step 4: find the battle 's name and date of the results of step 3 whose ship 's name equals HMS Atalanta",
      "Step 5: show the rows that are in both the results of step 2 and step 4"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        22
      ]
    ],
    "edits": [
      "name equals \"Lettice\"",
      "disposition of ship equals \"Lettice\""
    ],
    "edits_original": "< where > add name equals \" Lettice \" </ where > < where > remove disposition of ship equals \" Lettice \" </ where >"
  },
  {
    "question": "What are the notes of the death events which has substring 'East'?",
    "db_id": "battle_death",
    "gold_parse": "SELECT note FROM death WHERE note LIKE '%East%'",
    "feedback": "Switch killed with \"note\".",
    "predicted_parse_with_values": "select note from death where killed like \"%East%\"",
    "template_feedback": "consider the note like % East % conditions in place of the killed like % East % conditions .",
    "predicted_parse_explanation": [
      "find the note in death table whose killed like % East %"
    ],
    "primary_span": [
      [
        0,
        7
      ]
    ],
    "secondary_span": [
      [
        8,
        18
      ]
    ],
    "edits": [
      "note like \"%East%\"",
      "killed like \"%East%\""
    ],
    "edits_original": "< where > add note like \" % East % \" </ where > < where > remove killed like \" % East % \" </ where >"
  },
  {
    "question": "What is the first and second line for all addresses?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT line_1 ,  line_2 FROM addresses",
    "feedback": "Interchange second line 1 with \"line 2\".",
    "predicted_parse_with_values": "select line_1 , line_1 from Addresses",
    "template_feedback": "additionally find line 2 .",
    "predicted_parse_explanation": [
      "find the line 1 and line 1 in addresses table"
    ],
    "primary_span": [
      [
        0,
        4
      ]
    ],
    "secondary_span": [],
    "edits": [
      "line 2",
      "line 1"
    ],
    "edits_original": "< select > add line 2 </ select > < select > remove line 1 </ select >"
  },
  {
    "question": "For each department id, what is the name of the department with the most number of degrees?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT T2.department_name ,  T1.department_id FROM Degree_Programs AS T1 JOIN Departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T1.department_id ORDER BY count(*) DESC LIMIT 1",
    "feedback": "In step 3 use departments 's department name instead of degree programs 's department id .",
    "predicted_parse_with_values": "select T1.department_name , count ( * ) from Departments as T1 join Degree_Programs as T2 on T1.department_id = T2.department_id group by T2.department_id order by count ( * ) desc limit 1",
    "template_feedback": "in step 3 , find degree programs 's department id in place of number of rows .",
    "predicted_parse_explanation": [
      "Step 1: for each row in departments table , find the corresponding rows in degree programs table",
      "Step 2: find the number of rows of each value of degree programs 's department id of the results of step 1",
      "Step 3: find the department name and number of rows of the results of step 1 with largest value in the results of step 2"
    ],
    "primary_span": [
      [
        4,
        9
      ]
    ],
    "secondary_span": [
      [
        10,
        16
      ]
    ],
    "edits": [
      "department id",
      "number of rows"
    ],
    "edits_original": "< select > add department id </ select > < select > remove number of rows </ select >"
  },
  {
    "question": "How many degrees does the engineering department have?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT count(*) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id  =  T2.department_id WHERE T1.department_name  =  'engineer'",
    "feedback": "Switch departments table with degree programs table . Find whose corresponding department name equals engineering .",
    "predicted_parse_with_values": "select count ( * ) from Departments where department_name = \"engineer\"",
    "template_feedback": "additionally use the information from the degree programs table besides the departments table .",
    "predicted_parse_explanation": [
      "find the number of rows in departments table whose department name equals engineer"
    ],
    "primary_span": [
      [
        0,
        8
      ]
    ],
    "secondary_span": [
      [
        9,
        13
      ]
    ],
    "edits": [
      "degree programs"
    ],
    "edits_original": "< from > add degree programs </ from >"
  },
  {
    "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'",
    "feedback": "Whose corresponding degree summary name of degree programs table equals Bachelors .",
    "predicted_parse_with_values": "select first_name , middle_name , last_name from Students",
    "template_feedback": "additionally use the information from the student enrolment table and degree programs table besides the students table . additionally make sure that degree summary name equals Bachelor . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "find the first name , middle name , last name in students table"
    ],
    "primary_span": [
      [
        0,
        12
      ],
      [
        18,
        27
      ],
      [
        28,
        35
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ]
    ],
    "edits": [
      "distinct",
      "student enrolment",
      "degree programs",
      "degree summary name equals \"Bachelor\""
    ],
    "edits_original": "< select > add distinct </ select > < from > add student enrolment </ from > < from > add degree programs </ from > < where > add degree summary name equals \" Bachelor \" </ where >"
  },
  {
    "question": "What is the degree summary name that has the most number of students enrolled?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1",
    "feedback": "Step 1 Swap degree summary name in degree programs table\" with degree program id of student enrolment Step 2 Ensure Correspondence .",
    "predicted_parse_with_values": "select degree_summary_name from Degree_Programs group by degree_summary_name order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the student enrolment table besides the degree programs table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of degree summary name in degree programs table",
      "Step 2: find the degree summary name in degree programs table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        12
      ]
    ],
    "secondary_span": [
      [
        13,
        18
      ]
    ],
    "edits": [
      "student enrolment"
    ],
    "edits_original": "< from > add student enrolment </ from >"
  },
  {
    "question": "What are all the course names of the courses which ever have students enrolled in?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT DISTINCT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id",
    "feedback": "Make sure to find for whose course id is present under student enrolment courses table .",
    "predicted_parse_with_values": "select course_name from Courses",
    "template_feedback": "additionally use the information from the student enrolment courses table besides the courses table . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "find the course name in courses table"
    ],
    "primary_span": [
      [
        0,
        9
      ],
      [
        15,
        22
      ]
    ],
    "secondary_span": [
      [
        10,
        14
      ]
    ],
    "edits": [
      "distinct",
      "student enrolment courses"
    ],
    "edits_original": "< select > add distinct </ select > < from > add student enrolment courses </ from >"
  },
  {
    "question": "What's the name of the course with most number of enrollments?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1",
    "feedback": "There should be course id in student enrolment courses in place of course name in courses table in step 1.",
    "predicted_parse_with_values": "select course_name from Courses group by course_name order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the student enrolment courses table besides the courses table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of course name in courses table",
      "Step 2: find the course name in courses table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        13
      ]
    ],
    "secondary_span": [
      [
        14,
        18
      ]
    ],
    "edits": [
      "student enrolment courses"
    ],
    "edits_original": "< from > add student enrolment courses </ from >"
  },
  {
    "question": "Show the date and id of the transcript with at least 2 course results.",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*)  >=  2",
    "feedback": "Interchange transcripts table with transcript contents table in step 1.",
    "predicted_parse_with_values": "select transcript_date , transcript_id from Transcripts group by transcript_id having count ( * ) > = 2",
    "template_feedback": "in step 1 , additionally use the information from the transcript contents table besides the transcripts table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of transcript id in transcripts table",
      "Step 2: find the transcript date and transcript id in transcripts table whose corresponding value in step 1 is greater than or equals 2"
    ],
    "primary_span": [
      [
        4,
        12
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ]
    ],
    "edits": [
      "transcript contents"
    ],
    "edits_original": "< from > add transcript contents </ from >"
  },
  {
    "question": "Which address holds the most number of students currently? List the address id and all lines.",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1",
    "feedback": "in step 3 find address id , line 1 , line 2 , line 1 3 instead of current address id .",
    "predicted_parse_with_values": "select T2.address_id , count ( * ) from Students as T1 join Addresses as T2 on T1.permanent_address_id = T2.address_id group by T1.current_address_id order by count ( * ) desc limit 1",
    "template_feedback": "in step 3 , find line 2 and line 1 in place of number of rows .",
    "predicted_parse_explanation": [
      "Step 1: for each row in students table , find the corresponding rows in addresses table",
      "Step 2: find the number of rows of each value of current address id of the results of step 1",
      "Step 3: find the address id and number of rows of the results of step 1 with largest value in the results of step 2"
    ],
    "primary_span": [
      [
        4,
        9
      ]
    ],
    "secondary_span": [
      [
        10,
        16
      ]
    ],
    "edits": [
      "line 1",
      "line 2",
      "number of rows",
      "address id",
      "current address id"
    ],
    "edits_original": "< select > add line 1 </ select > < select > add line 2 </ select > < select > remove number of rows </ select > < groupBy > add address id </ groupBy > < groupBy > remove current address id </ groupBy >"
  },
  {
    "question": "Show the date of the transcript which shows the least number of results, also list the id.",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id ORDER BY count(*) ASC LIMIT 1",
    "feedback": "Change transcripts table with transcript contents in step 1 , first transcript id with transcript id n step 2.",
    "predicted_parse_with_values": "select transcript_date , transcript_date from Transcripts group by transcript_id order by count ( * ) asc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the transcript contents table besides the transcripts table . in step 2 , additionally find transcript contents 's transcript id .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of transcript id in transcripts table",
      "Step 2: find the transcript date and transcript date in transcripts table with smallest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        12
      ],
      [
        22,
        29
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ]
    ],
    "edits": [
      "transcript id",
      "transcript date",
      "transcript contents"
    ],
    "edits_original": "< select > add transcript id </ select > < select > remove transcript date </ select > < from > add transcript contents </ from >"
  },
  {
    "question": "What is the date and id of the transcript with the least number of results?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id ORDER BY count(*) ASC LIMIT 1",
    "feedback": "In Step 1 Replace transcripts table\" with transcript contents table\". Step 2 Replace one transcript date with transcript id",
    "predicted_parse_with_values": "select transcript_date , transcript_date from Transcripts group by transcript_id order by count ( * ) asc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the transcript contents table besides the transcripts table . in step 2 , additionally find transcript contents 's transcript id .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of transcript id in transcripts table",
      "Step 2: find the transcript date and transcript date in transcripts table with smallest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        12
      ],
      [
        22,
        29
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ]
    ],
    "edits": [
      "transcript id",
      "transcript date",
      "transcript contents"
    ],
    "edits_original": "< select > add transcript id </ select > < select > remove transcript date </ select > < from > add transcript contents </ from >"
  },
  {
    "question": "Find the semester when both Master students and Bachelor students got enrolled in.",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'",
    "feedback": "Also add degree programs table in step 1 , change first name with degree summary name in step 2.",
    "predicted_parse_with_values": "select T3.semester_name from Students as T1 join Student_Enrolment as T2 on T1.student_id = T2.student_id join Semesters as T3 on T2.semester_id = T3.semester_id where T1.first_name = \"Master\" intersect select T4.semester_name from Semesters as T4 join Student_Enrolment as T5 on T4.semester_id = T5.semester_id join Degree_Programs as T6 on T5.degree_program_id = T6.degree_program_id where T6.degree_summary_name = \"Bachelor\"",
    "template_feedback": "in step 1 , use degree programs table in place of students table and semesters table in step 2 , consider the degree summary name equals Master conditions in place of the first name equals Master conditions . find student enrolment 's semester id in place of semester name . make sure no repetition in the results . in step 3 , do not use the semesters table . in step 4 , find student enrolment 's semester id in place of semester name . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "Step 1: for each row in students table , find the corresponding rows in student enrolment table and in semesters table",
      "Step 2: find the semester name of the results of step 1 whose first name equals Master",
      "Step 3: for each row in semesters table , find the corresponding rows in student enrolment table and in degree programs table",
      "Step 4: find the semester name of the results of step 3 whose degree summary name equals Bachelor",
      "Step 5: show the rows that are in both the results of step 2 and step 4"
    ],
    "primary_span": [
      [
        4,
        7
      ],
      [
        20,
        27
      ],
      [
        38,
        43
      ],
      [
        50,
        57
      ],
      [
        62,
        68
      ],
      [
        73,
        78
      ],
      [
        85,
        92
      ]
    ],
    "secondary_span": [
      [
        8,
        15
      ],
      [
        28,
        37
      ],
      [
        44,
        49
      ],
      [
        62,
        68
      ],
      [
        79,
        84
      ]
    ],
    "edits": [
      "distinct",
      "semester id",
      "semester name",
      "degree programs",
      "students",
      "semesters",
      "degree summary name equals \"Master\"",
      "first name equals \"Master\"",
      "distinct",
      "semester id",
      "semester name",
      "semesters"
    ],
    "edits_original": "< select > add distinct </ select > < select > add semester id </ select > < select > remove semester name </ select > < from > add degree programs </ from > < from > remove students </ from > < from > remove semesters </ from > < where > add degree summary name equals \" Master \" </ where > < where > remove first name equals \" Master \" </ where > < select > add distinct </ select > < select > add semester id </ select > < select > remove semester name </ select > < from > remove semesters </ from >"
  },
  {
    "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'",
    "feedback": "In step 1 , Exchange student enrolment 's degree programs equals 12 with Corresponding degree programs 's degree summary name equals Masters",
    "predicted_parse_with_values": "select semester_id from Student_Enrolment where degree_program_id = 12 intersect select T1.semester_id from Student_Enrolment as T1 join Degree_Programs as T2 on T1.degree_program_id = T2.degree_program_id where T2.degree_summary_name = \"Bachelor\"",
    "template_feedback": "in step 1 , additionally use the information from the degree programs table besides the student enrolment table . consider the degree summary name equals Master conditions in place of the student enrolment 's degree program id equals 12 conditions . make sure no repetition in the results . in step 3 , make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "Step 1: find the semester id in student enrolment table whose student enrolment 's degree program id equals 12",
      "Step 2: for each row in student enrolment table , find the corresponding rows in degree programs table",
      "Step 3: find the semester id of the results of step 2 whose degree summary name equals Bachelor",
      "Step 4: show the rows that are in both the results of step 1 and step 3"
    ],
    "primary_span": [
      [
        4,
        12
      ],
      [
        19,
        26
      ],
      [
        41,
        48
      ],
      [
        53,
        60
      ]
    ],
    "secondary_span": [
      [
        13,
        18
      ],
      [
        27,
        40
      ]
    ],
    "edits": [
      "distinct",
      "degree programs",
      "degree summary name equals \"Master\"",
      "degree program id equals 12",
      "distinct"
    ],
    "edits_original": "< select > add distinct </ select > < from > add degree programs </ from > < where > add degree summary name equals \" Master \" </ where > < where > remove degree program id equals 12 </ where > < select > add distinct </ select >"
  },
  {
    "question": "How many different addresses do the students currently live?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT count(DISTINCT current_address_id) FROM Students",
    "feedback": "Confirm to find students 's current addresses without repetition .",
    "predicted_parse_with_values": "select count ( * ) from Addresses",
    "template_feedback": "use students table in place of addresses table . find number of different current address id in place of number of rows .",
    "predicted_parse_explanation": [
      "find the number of rows in addresses table"
    ],
    "primary_span": [
      [
        0,
        2
      ],
      [
        9,
        15
      ]
    ],
    "secondary_span": [
      [
        3,
        8
      ],
      [
        16,
        22
      ]
    ],
    "edits": [
      "number of distinct current address id",
      "number of rows",
      "students",
      "addresses"
    ],
    "edits_original": "< select > add number of distinct current address id </ select > < select > remove number of rows </ select > < from > add students </ from > < from > remove addresses </ from >"
  },
  {
    "question": "What are the different addresses that have students living there?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT count(DISTINCT current_address_id) FROM Students",
    "feedback": "Find the unique rows of addresses table where students currently living .",
    "predicted_parse_with_values": "select ( * ) from Addresses",
    "template_feedback": "use students table in place of addresses table . find number of different current address id in place of rows .",
    "predicted_parse_explanation": [
      "find the rows in addresses table"
    ],
    "primary_span": [
      [
        0,
        2
      ],
      [
        9,
        15
      ]
    ],
    "secondary_span": [
      [
        3,
        8
      ],
      [
        16,
        20
      ]
    ],
    "edits": [
      "number of distinct current address id",
      "rows",
      "students",
      "addresses"
    ],
    "edits_original": "< select > add number of distinct current address id </ select > < select > remove rows </ select > < from > add students </ from > < from > remove addresses </ from >"
  },
  {
    "question": "What is the TV Channel that shows the cartoon \"The Rise of the Blue Beetle!\"? List the TV Channel's series name.",
    "db_id": "tvshow",
    "gold_parse": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Title = \"The Rise of the Blue Beetle!\"",
    "feedback": "Also find values of corresponding series name of tv channel .",
    "predicted_parse_with_values": "select Channel from Cartoon where Title = \"The Rise of the Blue Beetle!\"",
    "template_feedback": "additionally use the information from the tv channel table besides the cartoon table . find series name in place of channel .",
    "predicted_parse_explanation": [
      "find the channel in cartoon table whose title equals The Rise of the Blue Beetle !"
    ],
    "primary_span": [
      [
        0,
        8
      ],
      [
        14,
        16
      ]
    ],
    "secondary_span": [
      [
        9,
        13
      ],
      [
        17,
        21
      ]
    ],
    "edits": [
      "series name",
      "channel",
      "tv channel"
    ],
    "edits_original": "< select > add series name </ select > < select > remove channel </ select > < from > add tv channel </ from >"
  },
  {
    "question": "When did the episode \"A Love of a Lifetime\" air?",
    "db_id": "tvshow",
    "gold_parse": "SELECT Air_Date FROM TV_series WHERE Episode = \"A Love of a Lifetime\"",
    "feedback": "In Step 2 Swap original air date with \"Air Date\".",
    "predicted_parse_with_values": "select T1.Original_air_date from Cartoon as T1 join TV_Channel as T2 on T1.Channel = T2.id join TV_series as T3 on T2.id = T3.Channel where T3.Episode = \"A Love of a Lifetime\"",
    "template_feedback": "in step 1 , do not use the tv channel table and cartoon table . in step 2 , find air date in place of original air date .",
    "predicted_parse_explanation": [
      "Step 1: for each row in cartoon table , find the corresponding rows in tv channel table and in tv series table",
      "Step 2: find the original air date of the results of step 1 whose episode equals A Love of a Lifetime"
    ],
    "primary_span": [
      [
        4,
        14
      ],
      [
        19,
        21
      ]
    ],
    "secondary_span": [
      [
        4,
        14
      ],
      [
        22,
        28
      ]
    ],
    "edits": [
      "air date",
      "original air date",
      "cartoon",
      "tv channel"
    ],
    "edits_original": "< select > add air date </ select > < select > remove original air date </ select > < from > remove cartoon </ from > < from > remove tv channel </ from >"
  },
  {
    "question": "What is the produdction code and channel of the most recent cartoon?",
    "db_id": "tvshow",
    "gold_parse": "SELECT production_code ,  channel FROM cartoon ORDER BY original_air_date LIMIT 1",
    "feedback": "Use Smallest value of original air date instead of largest value of original air date .",
    "predicted_parse_with_values": "select Production_code , Channel from Cartoon order by Original_air_date desc limit 1",
    "template_feedback": "use the smallest in place of largest .",
    "predicted_parse_explanation": [
      "find the production code and channel in cartoon table with largest value of original air date"
    ],
    "primary_span": [
      [
        0,
        2
      ]
    ],
    "secondary_span": [
      [
        3,
        7
      ]
    ],
    "edits": [
      "descending"
    ],
    "edits_original": "< orderBy > remove descending </ orderBy >"
  },
  {
    "question": "What are the ids of all tv channels that have more than 2 TV channels?",
    "db_id": "tvshow",
    "gold_parse": "SELECT id FROM tv_channel GROUP BY country HAVING count(*)  >  2",
    "feedback": "each value of country in step 1",
    "predicted_parse_with_values": "select id from TV_Channel group by id having count ( * ) > 2",
    "template_feedback": "in step 1 , find for value of country in place of id .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of id in tv channel table",
      "Step 2: find the id in tv channel table whose corresponding value in step 1 is greater than 2"
    ],
    "primary_span": [
      [
        4,
        8
      ]
    ],
    "secondary_span": [
      [
        9,
        13
      ]
    ],
    "edits": [
      "country",
      "id"
    ],
    "edits_original": "< groupBy > add country </ groupBy > < groupBy > remove id </ groupBy >"
  },
  {
    "question": "Return the names of all the poker players.",
    "db_id": "poker_player",
    "gold_parse": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID",
    "feedback": "Ensuring that people id is also present in poker player table .",
    "predicted_parse_with_values": "select Name from people",
    "template_feedback": "additionally use the information from the poker player table besides the people table .",
    "predicted_parse_explanation": [
      "find the name in people table"
    ],
    "primary_span": [
      [
        0,
        8
      ]
    ],
    "secondary_span": [
      [
        9,
        13
      ]
    ],
    "edits": [
      "poker player"
    ],
    "edits_original": "< from > add poker player </ from >"
  },
  {
    "question": "What are the contestant numbers and names of the contestants who had at least two votes?",
    "db_id": "voter_1",
    "gold_parse": "SELECT T1.contestant_number , T1.contestant_name FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number GROUP BY T1.contestant_number HAVING count(*)  >=  2",
    "feedback": "In step 1 replace contestants table with votes table .",
    "predicted_parse_with_values": "select contestant_number , contestant_name from CONTESTANTS group by contestant_number having count ( * ) > = 2",
    "template_feedback": "in step 1 , additionally use the information from the votes table besides the contestants table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of contestant number in contestants table",
      "Step 2: find the contestant number and contestant name in contestants table whose corresponding value in step 1 is greater than or equals 2"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "votes"
    ],
    "edits_original": "< from > add votes </ from >"
  },
  {
    "question": "Which continent is Anguilla in?",
    "db_id": "world_1",
    "gold_parse": "SELECT Continent FROM country WHERE Name  =  \"Anguilla\"",
    "feedback": "In step 2 swap language with name .",
    "predicted_parse_with_values": "select T1.Continent from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T2.Language = \"Anguilla\"",
    "template_feedback": "in step 1 , do not use the countrylanguage table . in step 2 , consider the name equals Anguilla conditions in place of the language equals Anguilla conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the continent of the results of step 1 whose language equals Anguilla"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        20
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        21,
        29
      ]
    ],
    "edits": [
      "countrylanguage",
      "name equals \"Anguilla\"",
      "language equals \"Anguilla\""
    ],
    "edits_original": "< from > remove countrylanguage </ from > < where > add name equals \" Anguilla \" </ where > < where > remove language equals \" Anguilla \" </ where >"
  },
  {
    "question": "What language is predominantly spoken in Aruba?",
    "db_id": "world_1",
    "gold_parse": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\" ORDER BY Percentage DESC LIMIT 1",
    "feedback": "Change local name with name of country table and ensure whose percentage value is largest .",
    "predicted_parse_with_values": "select T2.Language from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T1.LocalName = \"Aruba\"",
    "template_feedback": "in step 2 , consider the name equals Aruba conditions in place of the local name equals Aruba conditions . find the result with the largest percentage .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the language of the results of step 1 whose local name equals Aruba"
    ],
    "primary_span": [
      [
        4,
        9
      ],
      [
        20,
        27
      ]
    ],
    "secondary_span": [
      [
        10,
        19
      ]
    ],
    "edits": [
      "name equals \"Aruba\"",
      "local name equals \"Aruba\"",
      "percentage",
      "descending",
      "1"
    ],
    "edits_original": "< where > add name equals \" Aruba \" </ where > < where > remove local name equals \" Aruba \" </ where > < orderBy > add percentage </ orderBy > < orderBy > add descending </ orderBy > < limit > add 1 </ limit >"
  },
  {
    "question": "Give me Brazil's population and life expectancies.",
    "db_id": "world_1",
    "gold_parse": "SELECT Population ,  LifeExpectancy FROM country WHERE Name  =  \"Brazil\"",
    "feedback": "Swap continent with \"name\".",
    "predicted_parse_with_values": "select Population , LifeExpectancy from country where Continent = \"Brazil\"",
    "template_feedback": "consider the name equals Brazil conditions in place of the continent equals Brazil conditions .",
    "predicted_parse_explanation": [
      "find the population and life expectancy in country table whose continent equals Brazil"
    ],
    "primary_span": [
      [
        0,
        5
      ]
    ],
    "secondary_span": [
      [
        6,
        14
      ]
    ],
    "edits": [
      "name equals \"Brazil\"",
      "continent equals \"Brazil\""
    ],
    "edits_original": "< where > add name equals \" Brazil \" </ where > < where > remove continent equals \" Brazil \" </ where >"
  },
  {
    "question": "How many people live in Asia, and what is the largest GNP among them?",
    "db_id": "world_1",
    "gold_parse": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  \"Asia\"",
    "feedback": "Find population only once and Make sure that the continent equals Asia only .",
    "predicted_parse_with_values": "select Population , Population from country order by GNP desc limit 1",
    "template_feedback": "additionally make sure that continent equals Asia . additionally find maximum gnp . find summation of population in place of population . you should not find the largest of the results . show me all the results .",
    "predicted_parse_explanation": [
      "find the population and population in country table with largest value of gnp"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        8,
        12
      ],
      [
        13,
        16
      ],
      [
        22,
        37
      ]
    ],
    "secondary_span": [
      [
        17,
        21
      ]
    ],
    "edits": [
      "summation of population",
      "maximum gnp",
      "population",
      "continent equals \"Asia\"",
      "gnp",
      "descending",
      "1"
    ],
    "edits_original": "< select > add summation of population </ select > < select > add maximum gnp </ select > < select > remove population </ select > < where > add continent equals \" Asia \" </ where > < orderBy > remove gnp </ orderBy > < orderBy > remove descending </ orderBy > < limit > remove 1 </ limit >"
  },
  {
    "question": "What is the average life expectancy in African countries that are republics?",
    "db_id": "world_1",
    "gold_parse": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  \"Africa\" AND GovernmentForm  =  \"Republic\"",
    "feedback": "Also ensure government form equals Republic .",
    "predicted_parse_with_values": "select avg ( LifeExpectancy ) from country where Continent = \"Africa\"",
    "template_feedback": "additionally make sure that government form equals Republic .",
    "predicted_parse_explanation": [
      "find the average life expectancy in country table whose continent equals Africa"
    ],
    "primary_span": [
      [
        0,
        8
      ]
    ],
    "secondary_span": [],
    "edits": [
      "government form equals \"Republic\""
    ],
    "edits_original": "< where > add government form equals \" Republic \" </ where >"
  },
  {
    "question": "What is the total population of Gelderland district?",
    "db_id": "world_1",
    "gold_parse": "SELECT sum(Population) FROM city WHERE District  =  \"Gelderland\"",
    "feedback": "Need to find city 's population in place of country 's population .",
    "predicted_parse_with_values": "select sum ( T1.Population ) from country as T1 join city as T2 on T1.Code = T2.CountryCode where T2.District = \"Gelderland\"",
    "template_feedback": "in step 1 , do not use the country table . in step 2 , find summation of city 's population in place of summation of country 's population .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in city table",
      "Step 2: find the summation of country 's population of the results of step 1 whose district equals Gelderland"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        20
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        21,
        29
      ]
    ],
    "edits": [
      "country"
    ],
    "edits_original": "< from > remove country </ from >"
  },
  {
    "question": "Give the mean GNP and total population of nations which are considered US territory.",
    "db_id": "world_1",
    "gold_parse": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  \"US Territory\"",
    "feedback": "Make sure which are under US territory .",
    "predicted_parse_with_values": "select avg ( GNP ) , sum ( Population ) from country",
    "template_feedback": "additionally make sure that government form equals US Territory .",
    "predicted_parse_explanation": [
      "find the average gnp and summation of population in country table"
    ],
    "primary_span": [
      [
        0,
        9
      ]
    ],
    "secondary_span": [],
    "edits": [
      "government form equals \"US Territory\""
    ],
    "edits_original": "< where > add government form equals \" US Territory \" </ where >"
  },
  {
    "question": "What is the total number of languages used in Aruba?",
    "db_id": "world_1",
    "gold_parse": "SELECT COUNT(T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\"",
    "feedback": "Change capital with country 's name .",
    "predicted_parse_with_values": "select count ( T2.Language ) from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T1.Capital = \"Aruba\"",
    "template_feedback": "in step 2 , consider the name equals Aruba conditions in place of the capital equals Aruba conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the number of language of the results of step 1 whose capital equals Aruba"
    ],
    "primary_span": [
      [
        4,
        9
      ]
    ],
    "secondary_span": [
      [
        10,
        18
      ]
    ],
    "edits": [
      "name equals \"Aruba\"",
      "capital equals \"Aruba\""
    ],
    "edits_original": "< where > add name equals \" Aruba \" </ where > < where > remove capital equals \" Aruba \" </ where >"
  },
  {
    "question": "What is name of the country that speaks the largest number of languages?",
    "db_id": "world_1",
    "gold_parse": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name ORDER BY COUNT(*) DESC LIMIT 1",
    "feedback": "in step 1 change name in country table with language of countrylanguage table .",
    "predicted_parse_with_values": "select Name from country group by Name order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the countrylanguage table besides the country table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of name in country table",
      "Step 2: find the name in country table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "countrylanguage"
    ],
    "edits_original": "< from > add countrylanguage </ from >"
  },
  {
    "question": "Which continent has the most diverse languages?",
    "db_id": "world_1",
    "gold_parse": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1",
    "feedback": "Step 1 Swap continent of each value of continent with language of each value of countrycode",
    "predicted_parse_with_values": "select Continent from country group by Continent order by count ( Continent ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the countrylanguage table besides the country table . in step 2 , order the results by number of rows in place of number of continent .",
    "predicted_parse_explanation": [
      "Step 1: find the number of continent of each value of continent in country table",
      "Step 2: find the continent in country table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        21,
        27
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ],
      [
        28,
        34
      ]
    ],
    "edits": [
      "countrylanguage",
      "number of rows",
      "number of continent"
    ],
    "edits_original": "< from > add countrylanguage </ from > < orderBy > add number of rows </ orderBy > < orderBy > remove number of continent </ orderBy >"
  },
  {
    "question": "Which continent speaks the most languages?",
    "db_id": "world_1",
    "gold_parse": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1",
    "feedback": "In Step 1 Swap continent in country table\" with countrycode in countrylanguage table\" , Ensure Correspondence .",
    "predicted_parse_with_values": "select Continent from country group by Continent order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the countrylanguage table besides the country table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of continent in country table",
      "Step 2: find the continent in country table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "countrylanguage"
    ],
    "edits_original": "< from > add countrylanguage </ from >"
  },
  {
    "question": "Give the names of countries with English and French as official languages.",
    "db_id": "world_1",
    "gold_parse": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\" AND T2.IsOfficial  =  \"T\"",
    "feedback": "In step 2 also ensure language equals English , step 3 ensure is official equals T and language equals French .",
    "predicted_parse_with_values": "select T1.Name from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T2.IsOfficial = \"T\" intersect select T3.Name from country as T3 join countrylanguage as T4 on T3.Code = T4.CountryCode where T4.IsOfficial = \"French\"",
    "template_feedback": "in step 2 , additionally make sure that language equals English . in step 4 , consider the is official equals T and language equals French conditions in place of the is official equals French conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the name of the results of step 1 whose is official equals T",
      "Step 3: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 4: find the name of the results of step 3 whose is official equals French",
      "Step 5: show the rows that are in both the results of step 2 and step 4"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        16,
        26
      ]
    ],
    "secondary_span": [
      [
        27,
        36
      ]
    ],
    "edits": [
      "language equals \"English\"",
      "language equals \"French\"",
      "is official equals \"T\"",
      "is official equals \"French\""
    ],
    "edits_original": "< where > add language equals \" English \" </ where > < where > add language equals \" French \" </ where > < where > add is official equals \" T \" </ where > < where > remove is official equals \" French \" </ where >"
  },
  {
    "question": "What are the name, population, and life expectancy of the largest Asian country by land?",
    "db_id": "world_1",
    "gold_parse": "SELECT Name ,  Population ,  LifeExpectancy FROM country WHERE Continent  =  \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1",
    "feedback": "Use continent in place of region and change last life expectancy with surface area .",
    "predicted_parse_with_values": "select Name , Population , LifeExpectancy from country where Region = \"Asia\" order by LifeExpectancy desc limit 1",
    "template_feedback": "consider the continent equals Asia conditions in place of the region equals Asia conditions . order the results by surface area in place of life expectancy .",
    "predicted_parse_explanation": [
      "find the name , population , life expectancy in country table whose region equals Asia with largest value of life expectancy"
    ],
    "primary_span": [
      [
        0,
        5
      ],
      [
        15,
        20
      ]
    ],
    "secondary_span": [
      [
        6,
        14
      ],
      [
        21,
        26
      ]
    ],
    "edits": [
      "continent equals \"Asia\"",
      "region equals \"Asia\"",
      "surface area",
      "life expectancy"
    ],
    "edits_original": "< where > add continent equals \" Asia \" </ where > < where > remove region equals \" Asia \" </ where > < orderBy > add surface area </ orderBy > < orderBy > remove life expectancy </ orderBy >"
  },
  {
    "question": "What is the official language spoken in the country whose head of state is Beatrix?",
    "db_id": "world_1",
    "gold_parse": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.HeadOfState  =  \"Beatrix\" AND T2.IsOfficial  =  \"T\"",
    "feedback": "Ensure that is official equals true .",
    "predicted_parse_with_values": "select T2.Language from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T1.HeadOfState = \"Beatrix\"",
    "template_feedback": "in step 2 , additionally make sure that is official equals T .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the language of the results of step 1 whose head of state equals Beatrix"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [],
    "edits": [
      "is official equals \"T\""
    ],
    "edits_original": "< where > add is official equals \" T \" </ where >"
  },
  {
    "question": "What is the official language used in the country the name of whose head of state is Beatrix.",
    "db_id": "world_1",
    "gold_parse": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.HeadOfState  =  \"Beatrix\" AND T2.IsOfficial  =  \"T\"",
    "feedback": "Need to find language in step 2 and make sure is official is true",
    "predicted_parse_with_values": "select T2.IsOfficial from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T1.HeadOfState = \"Beatrix\"",
    "template_feedback": "in step 2 , additionally make sure that is official equals T . find language in place of is official .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the is official of the results of step 1 whose head of state equals Beatrix"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        12,
        13
      ]
    ],
    "secondary_span": [
      [
        14,
        19
      ]
    ],
    "edits": [
      "language",
      "is official",
      "is official equals \"T\""
    ],
    "edits_original": "< select > add language </ select > < select > remove is official </ select > < where > add is official equals \" T \" </ where >"
  },
  {
    "question": "What is the total number of unique official languages spoken in the countries that are founded before 1930?",
    "db_id": "world_1",
    "gold_parse": "SELECT count(DISTINCT T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE  IndepYear  <  1930 AND T2.IsOfficial  =  \"T\"",
    "feedback": "In Step 2 , Find district Count of language , Making sure is official is T .",
    "predicted_parse_with_values": "select count ( T2.Language ) from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T1.IndepYear < 1930",
    "template_feedback": "in step 2 , additionally make sure that is official equals T . find number of different language in place of number of language .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the number of language of the results of step 1 whose indepdent year less than 1930"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        12,
        16
      ]
    ],
    "secondary_span": [
      [
        17,
        23
      ]
    ],
    "edits": [
      "number of distinct language",
      "number of language",
      "is official equals \"T\""
    ],
    "edits_original": "< select > add number of distinct language </ select > < select > remove number of language </ select > < where > add is official equals \" T \" </ where >"
  },
  {
    "question": "For the countries founded before 1930, what is the total number of distinct official languages?",
    "db_id": "world_1",
    "gold_parse": "SELECT count(DISTINCT T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE  IndepYear  <  1930 AND T2.IsOfficial  =  \"T\"",
    "feedback": "find district number of language in countrylanguage whose is official equals T and indepdent year less than 1930.",
    "predicted_parse_with_values": "select count ( Name ) from country where IndepYear < 1930",
    "template_feedback": "additionally use the information from the countrylanguage table besides the country table . additionally make sure that is official equals T . find number of different language in place of number of name .",
    "predicted_parse_explanation": [
      "find the number of name in country table whose indepdent year less than 1930"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        13,
        20
      ],
      [
        21,
        25
      ]
    ],
    "secondary_span": [
      [
        8,
        12
      ],
      [
        26,
        32
      ]
    ],
    "edits": [
      "number of distinct language",
      "number of name",
      "countrylanguage",
      "is official equals \"T\""
    ],
    "edits_original": "< select > add number of distinct language </ select > < select > remove number of name </ select > < from > add countrylanguage </ from > < where > add is official equals \" T \" </ where >"
  },
  {
    "question": "What are the countries that have greater surface area than any country in Europe?",
    "db_id": "world_1",
    "gold_parse": "SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  \"Europe\")",
    "feedback": "In step 2 interchange continent with \"Name\"",
    "predicted_parse_with_values": "select Continent from country where SurfaceArea > ( select max ( SurfaceArea ) from country where Continent = \"Europe\" )",
    "template_feedback": "in step 1 , find minimum surface area in place of maximum surface area . in step 2 , find name in place of continent .",
    "predicted_parse_explanation": [
      "Step 1: find the maximum surface area in country table whose continent equals Europe",
      "Step 2: find the continent in country table whose surface area greater than the results of step 1"
    ],
    "primary_span": [
      [
        4,
        7
      ],
      [
        19,
        20
      ]
    ],
    "secondary_span": [
      [
        8,
        14
      ],
      [
        21,
        25
      ]
    ],
    "edits": [
      "name",
      "continent",
      "minimum surface area",
      "maximum surface area"
    ],
    "edits_original": "< select > add name </ select > < select > remove continent </ select > < select > add minimum surface area </ select > < select > remove maximum surface area </ select >"
  },
  {
    "question": "Which African countries have a smaller population than that of any country in Asia?",
    "db_id": "world_1",
    "gold_parse": "SELECT Name FROM country WHERE Continent  =  \"Africa\"  AND population  <  (SELECT min(population) FROM country WHERE Continent  =  \"Asia\")",
    "feedback": "Use continent equals Asia instead of continent equals Africa in 1st step .",
    "predicted_parse_with_values": "select Name from country where Population < ( select max ( Population ) from country where Continent = \"Asia\" )",
    "template_feedback": "in step 1 , find minimum population in place of maximum population . in step 2 , additionally make sure that continent equals Africa .",
    "predicted_parse_explanation": [
      "Step 1: find the maximum population in country table whose continent equals Asia",
      "Step 2: find the name in country table whose population less than the results of step 1"
    ],
    "primary_span": [
      [
        4,
        6
      ],
      [
        17,
        24
      ]
    ],
    "secondary_span": [
      [
        7,
        12
      ]
    ],
    "edits": [
      "continent equals \"Africa\"",
      "minimum population",
      "maximum population"
    ],
    "edits_original": "< where > add continent equals \" Africa \" </ where > < select > add minimum population </ select > < select > remove maximum population </ select >"
  },
  {
    "question": "What are the country codes of countries where people use languages other than English?",
    "db_id": "world_1",
    "gold_parse": "SELECT DISTINCT CountryCode FROM countrylanguage WHERE LANGUAGE != \"English\"",
    "feedback": "don 't repeat code in step 2",
    "predicted_parse_with_values": "select T1.Code from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T2.Language !=  \"English\"",
    "template_feedback": "in step 1 , do not use the country table . in step 2 , make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the code of the results of step 1 whose language not equals English"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        22
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ]
    ],
    "edits": [
      "distinct",
      "countrycode",
      "code",
      "country"
    ],
    "edits_original": "< select > add distinct </ select > < select > add countrycode </ select > < select > remove code </ select > < from > remove country </ from >"
  },
  {
    "question": "What are the codes of the countries that do not speak English and whose government forms are not Republic?",
    "db_id": "world_1",
    "gold_parse": "SELECT Code FROM country WHERE GovernmentForm != \"Republic\" EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
    "feedback": "Ensure that government form not equals Republic in step 2 , in step 3 change government form with language .",
    "predicted_parse_with_values": "select T1.Code from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T2.Language = \"English\" except select Code from country where GovernmentForm = \"English\"",
    "template_feedback": "in step 1 , do not use the countrylanguage table . in step 2 , consider the government form not equals Republic conditions in place of the language equals English conditions . in step 3 , use countrylanguage table in place of country table . consider the language equals English conditions in place of the government form equals English conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the code of the results of step 1 whose language equals English",
      "Step 3: find the code in country table whose government form equals English",
      "Step 4: show the rows that are in the results of step 2 but not in the results of step 3"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        22
      ],
      [
        36,
        38
      ],
      [
        45,
        50
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        23,
        31
      ],
      [
        39,
        44
      ],
      [
        51,
        60
      ]
    ],
    "edits": [
      "countrylanguage",
      "government form not equals to \"Republic\"",
      "language equals \"English\"",
      "countrycode",
      "code",
      "countrylanguage",
      "country",
      "language equals \"English\"",
      "government form equals \"English\""
    ],
    "edits_original": "< from > remove countrylanguage </ from > < where > add government form not equals to \" Republic \" </ where > < where > remove language equals \" English \" </ where > < select > add countrycode </ select > < select > remove code </ select > < from > add countrylanguage </ from > < from > remove country </ from > < where > add language equals \" English \" </ where > < where > remove government form equals \" English \" </ where >"
  },
  {
    "question": "Whic`h unique cities are in Asian countries where Chinese is the official language?",
    "db_id": "world_1",
    "gold_parse": "SELECT DISTINCT T3.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode JOIN city AS T3 ON T1.Code  =  T3.CountryCode WHERE T2.IsOfficial  =  'T' AND T2.Language  =  'Chinese' AND T1.Continent  =  \"Asia\"",
    "feedback": "Find city 's name without repetition , change region with is official and ensure that whose continent equals Asia .",
    "predicted_parse_with_values": "select T1.Name from city as T1 join country as T2 on T1.CountryCode = T2.Code join countrylanguage as T3 on T2.Code = T3.CountryCode where T2.Region = \"T\" and T3.Language = \"Chinese\"",
    "template_feedback": "in step 2 , consider the is official equals T and continent equals Asia conditions in place of the region equals T conditions . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "Step 1: for each row in city table , find the corresponding rows in country table and in countrylanguage table",
      "Step 2: find the city 's name of the results of step 1 whose region equals T and language equals Chinese"
    ],
    "primary_span": [
      [
        4,
        14
      ],
      [
        24,
        31
      ]
    ],
    "secondary_span": [
      [
        15,
        23
      ]
    ],
    "edits": [
      "distinct",
      "is official equals \"T\"",
      "continent equals \"Asia\"",
      "region equals \"T\""
    ],
    "edits_original": "< select > add distinct </ select > < where > add is official equals \" T \" </ where > < where > add continent equals \" Asia \" </ where > < where > remove region equals \" T \" </ where >"
  },
  {
    "question": "What are the population, name and leader of the country with the largest area?",
    "db_id": "world_1",
    "gold_parse": "SELECT Name ,  population ,  HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1",
    "feedback": "Swap local name with name , government form with head of state .",
    "predicted_parse_with_values": "select Population , LocalName , GovernmentForm from country order by SurfaceArea desc limit 1",
    "template_feedback": "find name and head of state in place of government form and local name .",
    "predicted_parse_explanation": [
      "find the population , local name , government form in country table with largest value of surface area"
    ],
    "primary_span": [
      [
        0,
        5
      ]
    ],
    "secondary_span": [
      [
        6,
        14
      ]
    ],
    "edits": [
      "name",
      "head of state",
      "local name",
      "government form"
    ],
    "edits_original": "< select > add name </ select > < select > add head of state </ select > < select > remove local name </ select > < select > remove government form </ select >"
  },
  {
    "question": "Find the average life expectancy and total population for each continent where the average life expectancy is shorter than 72?",
    "db_id": "world_1",
    "gold_parse": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  72",
    "feedback": "Swap second life expectancy with population . And average life expectancy in place of continent .",
    "predicted_parse_with_values": "select avg ( LifeExpectancy ) , sum ( LifeExpectancy ) from country where Continent < 72",
    "template_feedback": "remove the continent less than 72 conditions . find for each value of continent whose average life expectancy less than 72 . find summation of population and continent in place of summation of life expectancy .",
    "predicted_parse_explanation": [
      "find the average life expectancy and summation of life expectancy in country table whose continent less than 72"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        8,
        21
      ],
      [
        22,
        27
      ]
    ],
    "secondary_span": [
      [
        28,
        35
      ]
    ],
    "edits": [
      "summation of population",
      "continent",
      "summation of life expectancy",
      "continent less than 72",
      "continent",
      "average life expectancy less than 72"
    ],
    "edits_original": "< select > add summation of population </ select > < select > add continent </ select > < select > remove summation of life expectancy </ select > < where > remove continent less than 72 </ where > < groupBy > add continent </ groupBy > < having > add average life expectancy less than 72 </ having >"
  },
  {
    "question": "What are the names and areas of countries with the top 5 largest area?",
    "db_id": "world_1",
    "gold_parse": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5",
    "feedback": "find surface area instead of region",
    "predicted_parse_with_values": "select Name , Region from country order by SurfaceArea desc limit 5",
    "template_feedback": "in step 1 , find surface area in place of region .",
    "predicted_parse_explanation": [
      "Step 1: find the name and region in country table ordered descending by surface area",
      "Step 2: only show the first 5 rows of the results"
    ],
    "primary_span": [
      [
        4,
        6
      ]
    ],
    "secondary_span": [
      [
        7,
        11
      ]
    ],
    "edits": [
      "surface area",
      "region"
    ],
    "edits_original": "< select > add surface area </ select > < select > remove region </ select >"
  },
  {
    "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000?",
    "db_id": "world_1",
    "gold_parse": "SELECT sum(Population) ,  avg(SurfaceArea) FROM country WHERE Continent  =  \"North America\" AND SurfaceArea  >  3000",
    "feedback": "Replace second population with surface area , also ensure surface area should be greater than 3000.",
    "predicted_parse_with_values": "select sum ( Population ) , avg ( Population ) from country where Continent = \"North America\"",
    "template_feedback": "additionally make sure that surface area greater than 3000 . find average surface area in place of average population .",
    "predicted_parse_explanation": [
      "find the summation of population and average population in country table whose continent equals North America"
    ],
    "primary_span": [
      [
        0,
        9
      ],
      [
        10,
        13
      ]
    ],
    "secondary_span": [
      [
        14,
        19
      ]
    ],
    "edits": [
      "average surface area",
      "average population",
      "surface area greater than 3000"
    ],
    "edits_original": "< select > add average surface area </ select > < select > remove average population </ select > < where > add surface area greater than 3000 </ where >"
  },
  {
    "question": "Give the total population and average surface area corresponding to countries in Noth America that have a surface area greater than 3000.",
    "db_id": "world_1",
    "gold_parse": "SELECT sum(Population) ,  avg(SurfaceArea) FROM country WHERE Continent  =  \"North America\" AND SurfaceArea  >  3000",
    "feedback": "Ensuring surface area is Larger than 3000.",
    "predicted_parse_with_values": "select sum ( Population ) , avg ( SurfaceArea ) from country where Continent = \"North America\"",
    "template_feedback": "additionally make sure that surface area greater than 3000 .",
    "predicted_parse_explanation": [
      "find the summation of population and average surface area in country table whose continent equals North America"
    ],
    "primary_span": [
      [
        0,
        9
      ]
    ],
    "secondary_span": [],
    "edits": [
      "surface area greater than 3000"
    ],
    "edits_original": "< where > add surface area greater than 3000 </ where >"
  },
  {
    "question": "What is the language spoken by the largest percentage of people in each country?",
    "db_id": "world_1",
    "gold_parse": "SELECT LANGUAGE ,  CountryCode ,  max(Percentage) FROM countrylanguage GROUP BY CountryCode",
    "feedback": "In Step 2 Find language where percentage is highest for each district value of countrycode .",
    "predicted_parse_with_values": "select T2.Language , T2.Percentage from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode order by T1.Population desc limit 1",
    "template_feedback": "in step 1 , do not use the country table . in step 2 , find for each value of countrycode . additionally find countrycode . find maximum percentage in place of percentage . you should not find the largest of the results . show me all the results .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the language and percentage of the results of step 1 with largest value of population"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        21
      ],
      [
        22,
        25
      ],
      [
        26,
        28
      ],
      [
        34,
        49
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        29,
        33
      ]
    ],
    "edits": [
      "countrycode",
      "maximum percentage",
      "percentage",
      "country",
      "countrycode",
      "population",
      "descending",
      "1"
    ],
    "edits_original": "< select > add countrycode </ select > < select > add maximum percentage </ select > < select > remove percentage </ select > < from > remove country </ from > < groupBy > add countrycode </ groupBy > < orderBy > remove population </ orderBy > < orderBy > remove descending </ orderBy > < limit > remove 1 </ limit >"
  },
  {
    "question": "Count the number of countries for which Spanish is the predominantly spoken language.",
    "db_id": "world_1",
    "gold_parse": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode",
    "feedback": "Ensure whose percentage value is largest .",
    "predicted_parse_with_values": "select count ( T1.Name ) from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T2.Language = \"Spanish\"",
    "template_feedback": "in step 1 , do not use the country table . in step 2 , find for each value of countrycode . find number of rows and maximum percentage in place of number of name .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the number of name of the results of step 1 whose language equals Spanish"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        21
      ],
      [
        22,
        28
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        29,
        35
      ]
    ],
    "edits": [
      "number of rows",
      "maximum percentage",
      "number of name",
      "country",
      "countrycode"
    ],
    "edits_original": "< select > add number of rows </ select > < select > add maximum percentage </ select > < select > remove number of name </ select > < from > remove country </ from > < groupBy > add countrycode </ groupBy >"
  },
  {
    "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?",
    "db_id": "world_1",
    "gold_parse": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode",
    "feedback": "Swap population with percentage in step 2.",
    "predicted_parse_with_values": "select T1.Code from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T2.Language = \"Spanish\" order by T1.Population desc limit 1",
    "template_feedback": "in step 1 , do not use the country table . in step 2 , find for each value of countrycode . additionally find maximum percentage . you should not find the largest of the results . show me all the results .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the code of the results of step 1 whose language equals Spanish with largest value of population"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        21
      ],
      [
        22,
        26
      ],
      [
        27,
        42
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ]
    ],
    "edits": [
      "countrycode",
      "maximum percentage",
      "code",
      "country",
      "countrycode",
      "population",
      "descending",
      "1"
    ],
    "edits_original": "< select > add countrycode </ select > < select > add maximum percentage </ select > < select > remove code </ select > < from > remove country </ from > < groupBy > add countrycode </ groupBy > < orderBy > remove population </ orderBy > < orderBy > remove descending </ orderBy > < limit > remove 1 </ limit >"
  },
  {
    "question": "Return the codes of countries for which Spanish is the predominantly spoken language.",
    "db_id": "world_1",
    "gold_parse": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode",
    "feedback": "In step 2 ensure to find for largest value of percentage .",
    "predicted_parse_with_values": "select T1.Code from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T2.Language = \"Spanish\"",
    "template_feedback": "in step 1 , do not use the country table . in step 2 , find for each value of countrycode . additionally find maximum percentage .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the code of the results of step 1 whose language equals Spanish"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        21
      ],
      [
        22,
        26
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ]
    ],
    "edits": [
      "countrycode",
      "maximum percentage",
      "code",
      "country",
      "countrycode"
    ],
    "edits_original": "< select > add countrycode </ select > < select > add maximum percentage </ select > < select > remove code </ select > < from > remove country </ from > < groupBy > add countrycode </ groupBy >"
  },
  {
    "question": "What are the names of conductors who have conducted at more than one orchestra?",
    "db_id": "orchestra",
    "gold_parse": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID HAVING COUNT(*)  >  1",
    "feedback": "Replace conductor table with orchestra table in step 1.",
    "predicted_parse_with_values": "select Name from conductor group by Conductor_ID having count ( * ) > 1",
    "template_feedback": "in step 1 , additionally use the information from the orchestra table besides the conductor table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of conductor id in conductor table",
      "Step 2: find the name in conductor table whose corresponding value in step 1 is greater than 1"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "orchestra"
    ],
    "edits_original": "< from > add orchestra </ from >"
  },
  {
    "question": "Show the names of high school students and their corresponding number of friends.",
    "db_id": "network_1",
    "gold_parse": "SELECT T2.name ,  count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",
    "feedback": "Add friend 's student id ahead of corresponding rows to each value .",
    "predicted_parse_with_values": "select name , count ( * ) from Highschooler group by name",
    "template_feedback": "additionally use the information from the friend table besides the high schooler table . find for each value of student id in place of name .",
    "predicted_parse_explanation": [
      "find each value of name in high schooler table along with the number of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        14,
        20
      ]
    ],
    "secondary_span": [
      [
        8,
        13
      ],
      [
        21,
        25
      ]
    ],
    "edits": [
      "friend",
      "student id",
      "name"
    ],
    "edits_original": "< from > add friend </ from > < groupBy > add student id </ groupBy > < groupBy > remove name </ groupBy >"
  },
  {
    "question": "What are the names of the high schoolers and how many friends does each have?",
    "db_id": "network_1",
    "gold_parse": "SELECT T2.name ,  count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",
    "feedback": "Find Count of rows in Corresponding friend table along with name .",
    "predicted_parse_with_values": "select name , count ( * ) from Highschooler group by name",
    "template_feedback": "additionally use the information from the friend table besides the high schooler table . find for each value of student id in place of name .",
    "predicted_parse_explanation": [
      "find each value of name in high schooler table along with the number of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        14,
        20
      ]
    ],
    "secondary_span": [
      [
        8,
        13
      ],
      [
        21,
        25
      ]
    ],
    "edits": [
      "friend",
      "student id",
      "name"
    ],
    "edits_original": "< from > add friend </ from > < groupBy > add student id </ groupBy > < groupBy > remove name </ groupBy >"
  },
  {
    "question": "What are the names of high schoolers who have 3 or more friends?",
    "db_id": "network_1",
    "gold_parse": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  3",
    "feedback": "In Step 1 Supersede ID in high schooler table with student id in friend table.",
    "predicted_parse_with_values": "select name from Highschooler group by ID having count ( * ) >= 3",
    "template_feedback": "in step 1 , additionally use the information from the friend table besides the high schooler table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of id in high schooler table",
      "Step 2: find the name in high schooler table whose corresponding value in step 1 is greater than or equals 3"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        17
      ]
    ],
    "edits": [
      "friend",
      "student id",
      "id"
    ],
    "edits_original": "< from > add friend </ from > < groupBy > add student id </ groupBy > < groupBy > remove id </ groupBy >"
  },
  {
    "question": "Return the names of friends of the high school student Kyle.",
    "db_id": "network_1",
    "gold_parse": "SELECT T3.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id JOIN Highschooler AS T3 ON T1.friend_id  =  T3.id WHERE T2.name  =  \"Kyle\"",
    "feedback": "Need to find friend 's name of high schooler whose name equals Kyle .",
    "predicted_parse_with_values": "select name from Highschooler where grade = \"Kyle\"",
    "template_feedback": "additionally use the information from the friend table besides the high schooler table . consider the name equals Kyle conditions in place of the grade equals Kyle conditions .",
    "predicted_parse_explanation": [
      "find the name in high schooler table whose grade equals Kyle"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        14,
        19
      ]
    ],
    "secondary_span": [
      [
        8,
        13
      ],
      [
        20,
        28
      ]
    ],
    "edits": [
      "friend",
      "high schooler",
      "name equals \"Kyle\"",
      "grade equals \"Kyle\""
    ],
    "edits_original": "< from > add friend </ from > < from > add high schooler </ from > < where > add name equals \" Kyle \" </ where > < where > remove grade equals \" Kyle \" </ where >"
  },
  {
    "question": "What are the names of high schoolers who both have friends and are liked?",
    "db_id": "network_1",
    "gold_parse": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id INTERSECT SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.liked_id  =  T2.id",
    "feedback": "Step 1 Whose corresponding student id is in friend . Step 2 Whose corresponding student id is in likes .",
    "predicted_parse_with_values": "select name from Highschooler intersect select name from Highschooler",
    "template_feedback": "in step 1 , additionally use the information from the friend table besides the high schooler table . in step 2 , additionally use the information from the likes table besides the high schooler table .",
    "predicted_parse_explanation": [
      "Step 1: find the name in high schooler table",
      "Step 2: find the name in high schooler table",
      "Step 3: show the rows that are in both the results of step 1 and step 2"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        22,
        29
      ]
    ],
    "secondary_span": [
      [
        12,
        17
      ],
      [
        30,
        35
      ]
    ],
    "edits": [
      "friend",
      "likes"
    ],
    "edits_original": "< from > add friend </ from > < from > add likes </ from >"
  },
  {
    "question": "What are the names of high schoolers who have likes, and how many likes does each have?",
    "db_id": "network_1",
    "gold_parse": "SELECT T2.name ,  count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",
    "feedback": "Find high schooler 's name with number of the corresponding rows to each value of likes 's student id .",
    "predicted_parse_with_values": "select name , count ( * ) from Highschooler group by name",
    "template_feedback": "additionally use the information from the likes table besides the high schooler table . find for each value of student id in place of name .",
    "predicted_parse_explanation": [
      "find each value of name in high schooler table along with the number of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        14,
        20
      ]
    ],
    "secondary_span": [
      [
        8,
        13
      ],
      [
        21,
        25
      ]
    ],
    "edits": [
      "likes",
      "student id",
      "name"
    ],
    "edits_original": "< from > add likes </ from > < groupBy > add student id </ groupBy > < groupBy > remove name </ groupBy >"
  },
  {
    "question": "What is the name of the high schooler who has the greatest number of likes?",
    "db_id": "network_1",
    "gold_parse": "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
    "feedback": "in step 1 there should be student id in likes instead of id in high schooler table .",
    "predicted_parse_with_values": "select name from Highschooler group by ID order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the likes table besides the high schooler table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of id in high schooler table",
      "Step 2: find the name in high schooler table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        17
      ]
    ],
    "edits": [
      "likes",
      "student id",
      "id"
    ],
    "edits_original": "< from > add likes </ from > < groupBy > add student id </ groupBy > < groupBy > remove id </ groupBy >"
  },
  {
    "question": "Find the states where both owners and professionals live.",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT state FROM Owners INTERSECT SELECT state FROM Professionals",
    "feedback": "In Step 1 Switch professionals table with owners table .",
    "predicted_parse_with_values": "select state from Professionals intersect select state from Professionals",
    "template_feedback": "in step 1 , use owners table in place of professionals table . find owners 's state in place of professionals 's state .",
    "predicted_parse_explanation": [
      "Step 1: find the state in professionals table",
      "Step 2: find the state in professionals table",
      "Step 3: show the rows that are in both the results of step 1 and step 2"
    ],
    "primary_span": [
      [
        4,
        6
      ],
      [
        13,
        16
      ]
    ],
    "secondary_span": [
      [
        7,
        12
      ],
      [
        17,
        23
      ]
    ],
    "edits": [
      "owners",
      "professionals"
    ],
    "edits_original": "< from > add owners </ from > < from > remove professionals </ from >"
  },
  {
    "question": "What is the average age of the dogs who have gone through any treatments?",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )",
    "feedback": "For Whose dog id is also present in treatments table .",
    "predicted_parse_with_values": "select avg ( age ) from Dogs",
    "template_feedback": "additionally make sure that dog id is one of treatments 's dog id treatments .",
    "predicted_parse_explanation": [
      "find the average age in dogs table"
    ],
    "primary_span": [
      [
        0,
        14
      ]
    ],
    "secondary_span": [],
    "edits": [
      "dog id one of SUBS1",
      "dog id",
      "treatments"
    ],
    "edits_original": "< where > add dog id one of SUBS1 </ where > < select > add dog id </ select > < from > add treatments </ from >"
  },
  {
    "question": "Give me the id, role and email of the professionals who did not perform any treatment on dogs.",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT professional_id ,  role_code ,  email_address FROM Professionals EXCEPT SELECT T1.professional_id ,  T1.role_code ,  T1.email_address FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id",
    "feedback": "In Step 2 Only Find Whose professionals is present in treatments table .",
    "predicted_parse_with_values": "select professional_id , role_code , email_address from Professionals except select professional_id , role_code , email_address from Professionals",
    "template_feedback": "in step 2 , additionally use the information from the treatments table besides the professionals table .",
    "predicted_parse_explanation": [
      "Step 1: find the professional id , role code , email address in professionals table",
      "Step 2: find the professional id , role code , email address in professionals table",
      "Step 3: show the rows that are in the results of step 1 but not in the results of step 2"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "treatments"
    ],
    "edits_original": "< from > add treatments </ from >"
  },
  {
    "question": "Which professionals have done at least two treatments? List the professional's id, role, and first name.",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT T1.professional_id ,  T1.role_code ,  T1.first_name FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",
    "feedback": "In step 3 use first name in place of date of treatment .",
    "predicted_parse_with_values": "select T2.professional_id , T1.role_code , T2.date_of_treatment from Professionals as T1 join Treatments as T2 on T1.professional_id = T2.professional_id group by T2.professional_id having count ( * ) > = 2",
    "template_feedback": "in step 3 , find first name in place of date of treatment .",
    "predicted_parse_explanation": [
      "Step 1: for each row in professionals table , find the corresponding rows in treatments table",
      "Step 2: find the number of rows of each value of treatments 's professional id of the results of step 1",
      "Step 3: find the treatments 's professional id , role code , date of treatment of the results of step 1 whose corresponding value in step 2 is greater than or equals 2"
    ],
    "primary_span": [
      [
        4,
        6
      ]
    ],
    "secondary_span": [
      [
        7,
        13
      ]
    ],
    "edits": [
      "first name",
      "date of treatment"
    ],
    "edits_original": "< select > add first name </ select > < select > remove date of treatment </ select >"
  },
  {
    "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",
    "feedback": "need to add up all costs of treatments of each owners",
    "predicted_parse_with_values": "select T2.owner_id , T1.last_name from Owners as T1 join Dogs as T2 on T1.owner_id = T2.owner_id join Treatments as T3 on T2.dog_id = T3.dog_id order by T3.cost_of_treatment desc limit 1",
    "template_feedback": "in step 2 , find for each value of owners 's owner id . order the results by number of rows in place of cost of treatment .",
    "predicted_parse_explanation": [
      "Step 1: for each row in owners table , find the corresponding rows in dogs table and in treatments table",
      "Step 2: find the dogs 's owner id and last name of the results of step 1 with largest value of cost of treatment"
    ],
    "primary_span": [
      [
        4,
        13
      ],
      [
        14,
        20
      ]
    ],
    "secondary_span": [
      [
        21,
        27
      ]
    ],
    "edits": [
      "owner id",
      "number of rows",
      "cost of treatment"
    ],
    "edits_original": "< groupBy > add owner id </ groupBy > < orderBy > add number of rows </ orderBy > < orderBy > remove cost of treatment </ orderBy >"
  },
  {
    "question": "What is the description of the treatment type that costs the least money in total?",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT T1.treatment_type_description FROM Treatment_types AS T1 JOIN Treatments AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code GROUP BY T1.treatment_type_code ORDER BY sum(cost_of_treatment) ASC LIMIT 1",
    "feedback": "in step 2 , it should be the total summation of cost of treatment",
    "predicted_parse_with_values": "select T1.treatment_type_description from Treatment_Types as T1 join Treatments as T2 on T1.treatment_type_code = T2.treatment_type_code order by T2.cost_of_treatment asc limit 1",
    "template_feedback": "in step 2 , find for each value of treatment types 's treatment type code . order the results by summation of cost of treatment in place of cost of treatment .",
    "predicted_parse_explanation": [
      "Step 1: for each row in treatment types table , find the corresponding rows in treatments table",
      "Step 2: find the treatment type description of the results of step 1 with smallest value of cost of treatment"
    ],
    "primary_span": [
      [
        4,
        15
      ],
      [
        16,
        24
      ]
    ],
    "secondary_span": [
      [
        25,
        31
      ]
    ],
    "edits": [
      "treatment type code",
      "summation of cost of treatment",
      "cost of treatment"
    ],
    "edits_original": "< groupBy > add treatment type code </ groupBy > < orderBy > add summation of cost of treatment </ orderBy > < orderBy > remove cost of treatment </ orderBy >"
  },
  {
    "question": "Give me the description of the treatment type whose total cost is the lowest.",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT T1.treatment_type_description FROM Treatment_types AS T1 JOIN Treatments AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code GROUP BY T1.treatment_type_code ORDER BY sum(cost_of_treatment) ASC LIMIT 1",
    "feedback": "in step 2 use summation of cost of treatment of each treatment types",
    "predicted_parse_with_values": "select T1.treatment_type_description from Treatment_Types as T1 join Treatments as T2 on T1.treatment_type_code = T2.treatment_type_code order by T2.cost_of_treatment limit 1",
    "template_feedback": "in step 2 , find for each value of treatment types 's treatment type code . order the results by summation of cost of treatment in place of cost of treatment .",
    "predicted_parse_explanation": [
      "Step 1: for each row in treatment types table , find the corresponding rows in treatments table",
      "Step 2: find the treatment type description of the results of step 1 with smallest value of cost of treatment"
    ],
    "primary_span": [
      [
        4,
        15
      ],
      [
        16,
        24
      ]
    ],
    "secondary_span": [
      [
        25,
        31
      ]
    ],
    "edits": [
      "treatment type code",
      "summation of cost of treatment",
      "cost of treatment"
    ],
    "edits_original": "< groupBy > add treatment type code </ groupBy > < orderBy > add summation of cost of treatment </ orderBy > < orderBy > remove cost of treatment </ orderBy >"
  },
  {
    "question": "Which owner has paid the largest amount of money in total for their dogs? Show the owner id and zip code.",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT T1.owner_id ,  T1.zip_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY sum(T3.cost_of_treatment) DESC LIMIT 1",
    "feedback": "in step 2 , you should find the summation of cost of treatment instead of charge amount",
    "predicted_parse_with_values": "select T3.owner_id , T2.zip_code from Charges as T1 join Owners as T2 join Dogs as T3 group by T3.owner_id order by sum ( T1.charge_amount ) desc limit 1",
    "template_feedback": "in step 1 , use treatments table in place of charges table in step 3 , order the results by summation of cost of treatment in place of summation of charge amount .",
    "predicted_parse_explanation": [
      "Step 1: for each row in charges table , find the corresponding rows in owners table and in dogs table",
      "Step 2: find the summation of charge amount of each value of dogs 's owner id of the results of step 1",
      "Step 3: find the dogs 's owner id and zip code of the results of step 1 with largest value in the results of step 2"
    ],
    "primary_span": [
      [
        4,
        6
      ],
      [
        16,
        24
      ]
    ],
    "secondary_span": [
      [
        7,
        11
      ],
      [
        25,
        32
      ]
    ],
    "edits": [
      "treatments",
      "charges",
      "summation of cost of treatment",
      "summation of charge amount"
    ],
    "edits_original": "< from > add treatments </ from > < from > remove charges </ from > < orderBy > add summation of cost of treatment </ orderBy > < orderBy > remove summation of charge amount </ orderBy >"
  },
  {
    "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id",
    "feedback": "Swap date of treatment with date departed in step 2.",
    "predicted_parse_with_values": "select T1.date_arrived , T2.date_of_treatment from Dogs as T1 join Treatments as T2 on T1.dog_id = T2.dog_id",
    "template_feedback": "in step 2 , find date departed in place of date of treatment . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "Step 1: for each row in dogs table , find the corresponding rows in treatments table",
      "Step 2: find the date arrived and date of treatment of the results of step 1"
    ],
    "primary_span": [
      [
        4,
        6
      ],
      [
        14,
        21
      ]
    ],
    "secondary_span": [
      [
        7,
        13
      ]
    ],
    "edits": [
      "distinct",
      "date departed",
      "date of treatment"
    ],
    "edits_original": "< select > add distinct </ select > < select > add date departed </ select > < select > remove date of treatment </ select >"
  },
  {
    "question": "Find the arriving date and the departing date of the dogs that received a treatment.",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id",
    "feedback": "Assuring that the dog id of dogs is also present in treatments table .",
    "predicted_parse_with_values": "select date_arrived , date_departed from Dogs",
    "template_feedback": "additionally use the information from the treatments table besides the dogs table . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "find the date arrived and date departed in dogs table"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        13,
        20
      ]
    ],
    "secondary_span": [
      [
        8,
        12
      ]
    ],
    "edits": [
      "distinct",
      "treatments"
    ],
    "edits_original": "< select > add distinct </ select > < from > add treatments </ from >"
  },
  {
    "question": "Which professionals live in a city containing the substring 'West'? List his or her role, street, city and state.",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT role_code ,  street ,  city ,  state FROM professionals WHERE city LIKE '%West%'",
    "feedback": "Change first name with role code , also find city .",
    "predicted_parse_with_values": "select first_name , street , state from Professionals where city like \"%West%\"",
    "template_feedback": "find city and role code in place of first name .",
    "predicted_parse_explanation": [
      "find the first name , street , state in professionals table whose city like % West %"
    ],
    "primary_span": [
      [
        0,
        4
      ]
    ],
    "secondary_span": [
      [
        5,
        10
      ]
    ],
    "edits": [
      "role code",
      "city",
      "first name"
    ],
    "edits_original": "< select > add role code </ select > < select > add city </ select > < select > remove first name </ select >"
  },
  {
    "question": "Find the role, street, city and state of the professionals living in a city that contains the substring 'West'.",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT role_code ,  street ,  city ,  state FROM professionals WHERE city LIKE '%West%'",
    "feedback": "Replace first \"state\" with \"city\".",
    "predicted_parse_with_values": "select role_code , street , state , state from Professionals where city like \"%West%\"",
    "template_feedback": "additionally find city .",
    "predicted_parse_explanation": [
      "find the role code , street , state , state in professionals table whose city like % West %"
    ],
    "primary_span": [
      [
        0,
        3
      ]
    ],
    "secondary_span": [],
    "edits": [
      "city",
      "state"
    ],
    "edits_original": "< select > add city </ select > < select > remove state </ select >"
  },
  {
    "question": "Tell me the number of dogs that have received any treatment.",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT count(*) FROM Dogs WHERE dog_id NOT IN ( SELECT dog_id FROM Treatments )",
    "feedback": "Find number of dog id without repetition .",
    "predicted_parse_with_values": "select count ( dog_id ) from Treatments",
    "template_feedback": "use dogs table in place of treatments table . additionally make sure that dogs 's dog id is not one of treatments 's dog id treatments . find number of rows in place of number of treatments 's dog id .",
    "predicted_parse_explanation": [
      "find the number of dog id in treatments table"
    ],
    "primary_span": [
      [
        0,
        2
      ],
      [
        9,
        26
      ],
      [
        27,
        30
      ]
    ],
    "secondary_span": [
      [
        3,
        8
      ],
      [
        31,
        40
      ]
    ],
    "edits": [
      "number of rows",
      "number of dog id",
      "dogs",
      "treatments",
      "dog id not one of SUBS1",
      "dog id",
      "treatments"
    ],
    "edits_original": "< select > add number of rows </ select > < select > remove number of dog id </ select > < from > add dogs </ from > < from > remove treatments </ from > < where > add dog id not one of SUBS1 </ where > < select > add dog id </ select > < from > add treatments </ from >"
  },
  {
    "question": "What is the age of the oldest dog?",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT max(age) FROM Dogs",
    "feedback": "Interchange date adopted with age .",
    "predicted_parse_with_values": "select age from Dogs order by date_adopted desc limit 1",
    "template_feedback": "find maximum age in place of age . you should not find the largest of the results . show me all the results .",
    "predicted_parse_explanation": [
      "find the age in dogs table with largest value of date adopted"
    ],
    "primary_span": [
      [
        0,
        2
      ],
      [
        8,
        23
      ]
    ],
    "secondary_span": [
      [
        3,
        7
      ]
    ],
    "edits": [
      "maximum age",
      "age",
      "date adopted",
      "descending",
      "1"
    ],
    "edits_original": "< select > add maximum age </ select > < select > remove age </ select > < orderBy > remove date adopted </ orderBy > < orderBy > remove descending </ orderBy > < limit > remove 1 </ limit >"
  },
  {
    "question": "How much does the most expensive charge type costs?",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT max(charge_amount) FROM Charges",
    "feedback": "Also need to find charge type along with charge amount .",
    "predicted_parse_with_values": "select charge_amount from Charges order by charge_amount desc limit 1",
    "template_feedback": "find maximum charge amount in place of charge amount . you should not find the largest of the results . show me all the results .",
    "predicted_parse_explanation": [
      "find the charge amount in charges table with largest value of charge amount"
    ],
    "primary_span": [
      [
        0,
        3
      ],
      [
        10,
        25
      ]
    ],
    "secondary_span": [
      [
        4,
        9
      ]
    ],
    "edits": [
      "maximum charge amount",
      "charge amount",
      "charge amount",
      "descending",
      "1"
    ],
    "edits_original": "< select > add maximum charge amount </ select > < select > remove charge amount </ select > < orderBy > remove charge amount </ orderBy > < orderBy > remove descending </ orderBy > < limit > remove 1 </ limit >"
  },
  {
    "question": "What are each professional's first name and description of the treatment they have performed?",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code",
    "feedback": "Find professionals 's first name and treatment types 's treatment type description whose professionals and treatment type code are present in treatments table .",
    "predicted_parse_with_values": "select first_name , last_name from Professionals",
    "template_feedback": "additionally use the information from the treatment types table and treatments table besides the professionals table . find treatment type description in place of last name . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "find the first name and last name in professionals table"
    ],
    "primary_span": [
      [
        0,
        11
      ],
      [
        17,
        20
      ],
      [
        27,
        34
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ],
      [
        21,
        26
      ]
    ],
    "edits": [
      "distinct",
      "treatment type description",
      "last name",
      "treatments",
      "treatment types"
    ],
    "edits_original": "< select > add distinct </ select > < select > add treatment type description </ select > < select > remove last name </ select > < from > add treatments </ from > < from > add treatment types </ from >"
  },
  {
    "question": "Show the names of singers that have more than one song.",
    "db_id": "singer",
    "gold_parse": "SELECT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name HAVING COUNT(*)  >  1",
    "feedback": "Use singer id in song table in place of name in singer table in step 1.",
    "predicted_parse_with_values": "select Name from singer group by Name having count ( * ) > 1",
    "template_feedback": "in step 1 , additionally use the information from the song table besides the singer table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of name in singer table",
      "Step 2: find the name in singer table whose corresponding value in step 1 is greater than 1"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "song"
    ],
    "edits_original": "< from > add song </ from >"
  },
  {
    "question": "What are the names of the singers that have more than one songs?",
    "db_id": "singer",
    "gold_parse": "SELECT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name HAVING COUNT(*)  >  1",
    "feedback": "In Step 1 Switch name in singer table with singer id in song table.",
    "predicted_parse_with_values": "select Name from singer group by Name having count ( * ) > 1",
    "template_feedback": "in step 1 , additionally use the information from the song table besides the singer table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of name in singer table",
      "Step 2: find the name in singer table whose corresponding value in step 1 is greater than 1"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "song"
    ],
    "edits_original": "< from > add song </ from >"
  },
  {
    "question": "Show the names of high schoolers who have likes, and numbers of likes for each.",
    "db_id": "network_1",
    "gold_parse": "SELECT T2.name ,  count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",
    "feedback": "Ensure the correspondence between tables and find liked id and count of liked id per name",
    "predicted_parse_with_values": "select name , count ( * ) from Highschooler group by name",
    "template_feedback": "additionally use the information from the likes table besides the high schooler table . find for each value of student id in place of name .",
    "predicted_parse_explanation": [
      "find each value of name in high schooler table along with the number of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        14,
        20
      ]
    ],
    "secondary_span": [
      [
        8,
        13
      ],
      [
        21,
        25
      ]
    ],
    "edits": [
      "likes",
      "student id",
      "name"
    ],
    "edits_original": "< from > add likes </ from > < groupBy > add student id </ groupBy > < groupBy > remove name </ groupBy >"
  },
  {
    "question": "Find the average age of losers and winners of all matches.",
    "db_id": "wta_1",
    "gold_parse": "SELECT avg(loser_age) ,  avg(winner_age) FROM matches",
    "feedback": "Find average loser age hand average winner age for each row.",
    "predicted_parse_with_values": "select avg ( winner_age ) , winner_rank from matches group by loser_id",
    "template_feedback": "do not find for each value of loser id . find average loser age in place of winner rank .",
    "predicted_parse_explanation": [
      "find each value of loser id in matches table along with the winner rank and average winner age of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        0,
        9
      ],
      [
        10,
        13
      ]
    ],
    "secondary_span": [
      [
        14,
        19
      ]
    ],
    "edits": [
      "average loser age",
      "winner rank",
      "loser id"
    ],
    "edits_original": "< select > add average loser age </ select > < select > remove winner rank </ select > < groupBy > remove loser id </ groupBy >"
  },
  {
    "question": "Find the owner id and zip code of the owner who spent the most money in total for his or her dogs.",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT T1.owner_id ,  T1.zip_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY sum(T3.cost_of_treatment) DESC LIMIT 1",
    "feedback": "Step 1 , Correspond treatments Step 2 , find summation of cost of treatment as well. Step 3 , Swap  dogs with  owners",
    "predicted_parse_with_values": "select T3.owner_id , T2.zip_code from Charges as T1 join Owners as T2 join Dogs as T3 group by T3.owner_id order by sum ( T1.charge_amount ) desc limit 1",
    "template_feedback": "in step 1 , use treatments table in place of charges table in step 3 , order the results by summation of cost of treatment in place of summation of charge amount .",
    "predicted_parse_explanation": [
      "Step 1: for each row in charges table , find the corresponding rows in owners table and in dogs table",
      "Step 2: find the summation of charge amount of each value of dogs 's owner id of the results of step 1",
      "Step 3: find the dogs 's owner id and zip code of the results of step 1 with largest value in the results of step 2"
    ],
    "primary_span": [
      [
        4,
        6
      ],
      [
        16,
        24
      ]
    ],
    "secondary_span": [
      [
        7,
        11
      ],
      [
        25,
        32
      ]
    ],
    "edits": [
      "treatments",
      "charges",
      "summation of cost of treatment",
      "summation of charge amount"
    ],
    "edits_original": "< from > add treatments </ from > < from > remove charges </ from > < orderBy > add summation of cost of treatment </ orderBy > < orderBy > remove summation of charge amount </ orderBy >"
  },
  {
    "question": "How many countries have governments that are republics?",
    "db_id": "world_1",
    "gold_parse": "SELECT count(*) FROM country WHERE GovernmentForm  =  \"Republic\"",
    "feedback": "Instead of number of government form , find number of Name.",
    "predicted_parse_with_values": "select count ( GovernmentForm ) from country where GovernmentForm = \"Republic\"",
    "template_feedback": "find number of rows in place of number of government form .",
    "predicted_parse_explanation": [
      "find the number of government form in country table whose government form equals Republic"
    ],
    "primary_span": [
      [
        0,
        3
      ]
    ],
    "secondary_span": [
      [
        4,
        11
      ]
    ],
    "edits": [
      "number of rows",
      "number of government form"
    ],
    "edits_original": "< select > add number of rows </ select > < select > remove number of government form </ select >"
  },
  {
    "question": "What is the average edispl for all volvos?",
    "db_id": "car_1",
    "gold_parse": "SELECT avg(T2.edispl) FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T1.Model  =  'volvo'",
    "feedback": "maker sure to find for corresponding car names 's model equals volvos.",
    "predicted_parse_with_values": "select avg ( Edispl ) from cars_data",
    "template_feedback": "additionally use the information from the car names table besides the cars data table . additionally make sure that model equals volvo .",
    "predicted_parse_explanation": [
      "find the average edispl in cars data table"
    ],
    "primary_span": [
      [
        0,
        8
      ],
      [
        15,
        22
      ]
    ],
    "secondary_span": [
      [
        9,
        14
      ]
    ],
    "edits": [
      "car names",
      "model equals \"volvo\""
    ],
    "edits_original": "< from > add car names </ from > < where > add model equals \" volvo \" </ where >"
  },
  {
    "question": "Among the cars that do not have the minimum horsepower, what are the make ids and names of al those with less than 4 cylinders?",
    "db_id": "car_1",
    "gold_parse": "SELECT T2.MakeId ,  T2.Make FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Horsepower  >  (SELECT min(Horsepower) FROM CARS_DATA) AND T1.Cylinders  <=  3",
    "feedback": "Step 2 , Change  ' 3 ' with  ' 4 ' , maker sure that horsepower is higher than the smallest horsepower",
    "predicted_parse_with_values": "select T2.MakeId , T2.Make from cars_data as T1 join car_names as T2 on T1.Id = T2.MakeId where T1.Cylinders < 3",
    "template_feedback": "in step 2 , consider the cylinders less than or equals 3 and horsepower is greater than minimum horsepower cars data conditions in place of the cylinders less than 3 conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in cars data table , find the corresponding rows in car names table",
      "Step 2: find the make id and make of the results of step 1 whose cylinders less than 3"
    ],
    "primary_span": [
      [
        4,
        21
      ]
    ],
    "secondary_span": [
      [
        22,
        31
      ]
    ],
    "edits": [
      "horsepower greater than SUBS1",
      "cylinders less than or equals to 3",
      "cylinders less than 3",
      "minimum horsepower",
      "cars data"
    ],
    "edits_original": "< where > add horsepower greater than SUBS1 </ where > < where > add cylinders less than or equals to 3 </ where > < where > remove cylinders less than 3 </ where > < select > add minimum horsepower </ select > < from > add cars data </ from >"
  },
  {
    "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2",
    "feedback": "Ensure semester id is same while finding count in step 2; Also find id in step 3.",
    "predicted_parse_with_values": "select T1.first_name , T1.middle_name , T1.last_name from Students as T1 join Student_Enrolment as T2 on T1.student_id = T2.student_id group by T2.degree_program_id having count ( * ) = 2",
    "template_feedback": "in step 2 , find for value of students 's student id in place of degree program id . in step 3 , additionally find students 's student id .",
    "predicted_parse_explanation": [
      "Step 1: for each row in students table , find the corresponding rows in student enrolment table",
      "Step 2: find the number of rows of each value of degree program id of the results of step 1",
      "Step 3: find the first name , middle name , last name of the results of step 1 whose corresponding value in step 2 is equals 2"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        23,
        29
      ]
    ],
    "secondary_span": [
      [
        12,
        18
      ]
    ],
    "edits": [
      "student id",
      "student id",
      "degree program id"
    ],
    "edits_original": "< select > add student id </ select > < groupBy > add student id </ groupBy > < groupBy > remove degree program id </ groupBy >"
  },
  {
    "question": "Of all the contestants who got voted, what is the contestant number and name of the contestant who got least votes?",
    "db_id": "voter_1",
    "gold_parse": "SELECT T1.contestant_number , T1.contestant_name FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number GROUP BY T1.contestant_number ORDER BY count(*) ASC LIMIT 1",
    "feedback": "In place of smallest value of vote id , it should find for smallest count of votes 's contestant number 2).",
    "predicted_parse_with_values": "select T1.contestant_number , T1.contestant_name from CONTESTANTS as T1 join VOTES as T2 on T1.contestant_number = T2.contestant_number order by T2.vote_id limit 1",
    "template_feedback": "in step 2 , find for each value of contestants 's contestant number . order the results by number of rows in place of vote id .",
    "predicted_parse_explanation": [
      "Step 1: for each row in contestants table , find the corresponding rows in votes table",
      "Step 2: find the contestants 's contestant number and contestant name of the results of step 1 with smallest value of vote id"
    ],
    "primary_span": [
      [
        4,
        13
      ],
      [
        14,
        20
      ]
    ],
    "secondary_span": [
      [
        21,
        26
      ]
    ],
    "edits": [
      "contestant number",
      "number of rows",
      "vote id"
    ],
    "edits_original": "< groupBy > add contestant number </ groupBy > < orderBy > add number of rows </ orderBy > < orderBy > remove vote id </ orderBy >"
  },
  {
    "question": "What is the name of the high schooler who has the greatest number of friends?",
    "db_id": "network_1",
    "gold_parse": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
    "feedback": "Step 1 , Replace name in high schooler with student id in friend Step 2 , Assure correspondence.",
    "predicted_parse_with_values": "select name from Highschooler group by name order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the friend table besides the high schooler table . find for each value of student id in place of name .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of name in high schooler table",
      "Step 2: find the name in high schooler table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        18,
        24
      ]
    ],
    "secondary_span": [
      [
        12,
        17
      ],
      [
        25,
        29
      ]
    ],
    "edits": [
      "friend",
      "student id",
      "name"
    ],
    "edits_original": "< from > add friend </ from > < groupBy > add student id </ groupBy > < groupBy > remove name </ groupBy >"
  },
  {
    "question": "Which are the car makers which produce at least 2 models and more than 3 car makes? List the id and the maker.",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3",
    "feedback": "Find car makers 's id , maker whose count of model list 's maker above 2 , and car names 's make id above 3.",
    "predicted_parse_with_values": "select Id , Maker from car_makers group by Id having count ( * ) > 2 intersect select Id , Maker from car_makers group by Id having count ( * ) > 3",
    "template_feedback": "in step 1 , additionally use the information from the model list table besides the car makers table . in step 2 , make sure that the corresponding value in step 1 greater than or equals 2 . in step 3 , additionally use the information from the car names table and model list table besides the car makers table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of id in car makers table",
      "Step 2: find the id and maker in car makers table whose corresponding value in step 1 is greater than 2",
      "Step 3: find the number of rows of each value of id in car makers table",
      "Step 4: find the id and maker in car makers table whose corresponding value in step 3 is greater than 3",
      "Step 5: show the rows that are in both the results of step 2 and step 4"
    ],
    "primary_span": [
      [
        4,
        12
      ],
      [
        23,
        37
      ],
      [
        42,
        54
      ]
    ],
    "secondary_span": [
      [
        13,
        18
      ],
      [
        55,
        60
      ]
    ],
    "edits": [
      "model list",
      "number of rows greater than or equals to 2",
      "number of rows greater than 2",
      "model list",
      "car names"
    ],
    "edits_original": "< from > add model list </ from > < having > add number of rows greater than or equals to 2 </ having > < having > remove number of rows greater than 2 </ having > < from > add model list </ from > < from > add car names </ from >"
  },
  {
    "question": "How many car models are produced by each maker? List the count and the maker full name.",
    "db_id": "car_1",
    "gold_parse": "SELECT Count(*) ,  T2.FullName ,  T2.id FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id GROUP BY T2.id",
    "feedback": "Find each maker in model list table with count of model and corresponding car makers 's full name",
    "predicted_parse_with_values": "select count ( * ) , Maker from car_makers group by Maker",
    "template_feedback": "additionally use the information from the model list table besides the car makers table . find for each value of id in place of car makers 's maker . find id and full name in place of car makers 's maker .",
    "predicted_parse_explanation": [
      "find each value of maker in car makers table along with the number of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        0,
        8
      ],
      [
        15,
        20
      ],
      [
        29,
        33
      ]
    ],
    "secondary_span": [
      [
        9,
        14
      ],
      [
        21,
        28
      ],
      [
        34,
        41
      ]
    ],
    "edits": [
      "full name",
      "id",
      "maker",
      "model list",
      "id",
      "maker"
    ],
    "edits_original": "< select > add full name </ select > < select > add id </ select > < select > remove maker </ select > < from > add model list </ from > < groupBy > add id </ groupBy > < groupBy > remove maker </ groupBy >"
  },
  {
    "question": "Give the flight numbers of flights leaving from APG.",
    "db_id": "flight_2",
    "gold_parse": "SELECT FlightNo FROM FLIGHTS WHERE SourceAirport  =  \"APG\"",
    "feedback": "Substitute airlines with source airport",
    "predicted_parse_with_values": "select FlightNo from flights where Airline = \"APG\"",
    "template_feedback": "consider the source airport equals APG conditions in place of the airline equals APG conditions .",
    "predicted_parse_explanation": [
      "find the flight number in flights table whose airline equals APG"
    ],
    "primary_span": [
      [
        0,
        6
      ]
    ],
    "secondary_span": [
      [
        7,
        15
      ]
    ],
    "edits": [
      "source airport equals \"APG\"",
      "airline equals \"APG\""
    ],
    "edits_original": "< where > add source airport equals \" APG \" </ where > < where > remove airline equals \" APG \" </ where >"
  },
  {
    "question": "What is the name of the winner with the most rank points who participated in the Australian Open tournament?",
    "db_id": "wta_1",
    "gold_parse": "SELECT winner_name FROM matches WHERE tourney_name  =  'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1",
    "feedback": "Supplant  tourney name in place of  winner rank",
    "predicted_parse_with_values": "select winner_name from matches where winner_rank = \"Australian Open\" order by winner_rank_points desc limit 1",
    "template_feedback": "consider the tourney name equals Australian Open conditions in place of the winner rank equals Australian Open conditions .",
    "predicted_parse_explanation": [
      "find the winner name in matches table whose winner rank equals Australian Open with largest value of winner rank points"
    ],
    "primary_span": [
      [
        0,
        7
      ]
    ],
    "secondary_span": [
      [
        8,
        18
      ]
    ],
    "edits": [
      "tourney name equals \"Australian Open\"",
      "winner rank equals \"Australian Open\""
    ],
    "edits_original": "< where > add tourney name equals \" Australian Open \" </ where > < where > remove winner rank equals \" Australian Open \" </ where >"
  },
  {
    "question": "What are the names of poker players?",
    "db_id": "poker_player",
    "gold_parse": "SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID",
    "feedback": "Make sure to find for people whose corresponding people id present in poker player table.",
    "predicted_parse_with_values": "select Name from people",
    "template_feedback": "additionally use the information from the poker player table besides the people table .",
    "predicted_parse_explanation": [
      "find the name in people table"
    ],
    "primary_span": [
      [
        0,
        8
      ]
    ],
    "secondary_span": [
      [
        9,
        13
      ]
    ],
    "edits": [
      "poker player"
    ],
    "edits_original": "< from > add poker player </ from >"
  },
  {
    "question": "Return the number of likes that the high schooler named Kyle has.",
    "db_id": "network_1",
    "gold_parse": "SELECT count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"",
    "feedback": "Find number of likes 's liked id where corresponding high schooler 's name equals Kyle.",
    "predicted_parse_with_values": "select count ( * ) from Highschooler where name = \"Kyle\"",
    "template_feedback": "additionally use the information from the likes table besides the high schooler table .",
    "predicted_parse_explanation": [
      "find the number of rows in high schooler table whose name equals Kyle"
    ],
    "primary_span": [
      [
        0,
        7
      ]
    ],
    "secondary_span": [
      [
        8,
        13
      ]
    ],
    "edits": [
      "likes"
    ],
    "edits_original": "< from > add likes </ from >"
  },
  {
    "question": "What are the name of the countries where there is not a single car maker?",
    "db_id": "car_1",
    "gold_parse": "SELECT CountryName FROM countries EXCEPT SELECT T1.CountryName FROM countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.countryId  =  T2.Country",
    "feedback": "In step 2 , Ensure to find only whose corresponding country id present in car makers 's country",
    "predicted_parse_with_values": "select CountryName from countries except select CountryName from countries",
    "template_feedback": "in step 2 , additionally use the information from the car makers table besides the countries table .",
    "predicted_parse_explanation": [
      "Step 1: find the country name in countries table",
      "Step 2: find the country name in countries table",
      "Step 3: show the rows that are in the results of step 1 but not in the results of step 2"
    ],
    "primary_span": [
      [
        4,
        12
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ]
    ],
    "edits": [
      "car makers"
    ],
    "edits_original": "< from > add car makers </ from >"
  },
  {
    "question": "For all of the 4 cylinder cars, which model has the most horsepower?",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1",
    "feedback": "Should find for largest value of horsepower in place of cylinders in step 2.",
    "predicted_parse_with_values": "select T2.Model from cars_data as T1 join car_names as T2 on T1.Id = T2.MakeId where T1.Cylinders = 4 order by T1.Cylinders desc limit 1",
    "template_feedback": "in step 2 , order the results by horsepower in place of cylinders .",
    "predicted_parse_explanation": [
      "Step 1: for each row in cars data table , find the corresponding rows in car names table",
      "Step 2: find the model of the results of step 1 whose cylinders equals 4 with largest value of cylinders"
    ],
    "primary_span": [
      [
        4,
        8
      ]
    ],
    "secondary_span": [
      [
        9,
        13
      ]
    ],
    "edits": [
      "horsepower",
      "cylinders"
    ],
    "edits_original": "< orderBy > add horsepower </ orderBy > < orderBy > remove cylinders </ orderBy >"
  },
  {
    "question": "How many car makers are there in each continents? List the continent name and the count.",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent",
    "feedback": "Correspond all tables , Also find number of car makers 's maker corresponding to each value of continents",
    "predicted_parse_with_values": "select Continent , count ( * ) from continents group by Continent",
    "template_feedback": "additionally use the information from the countries table and car makers table besides the continents table .",
    "predicted_parse_explanation": [
      "find each value of continent in continents table along with the number of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        0,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "countries",
      "car makers"
    ],
    "edits_original": "< from > add countries </ from > < from > add car makers </ from >"
  },
  {
    "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id",
    "feedback": "In step 2 , Ensure to take only those whose student id not present in student enrolment table.",
    "predicted_parse_with_values": "select T1.last_name from Students as T1 join Addresses as T2 on T1.permanent_address_id = T2.address_id where T2.state_province_county = \"NorthCarolina\" except select last_name from Students",
    "template_feedback": "in step 3 , additionally use the information from the student enrolment table besides the students table . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "Step 1: for each row in students table , find the corresponding rows in addresses table",
      "Step 2: find the last name of the results of step 1 whose state province county equals NorthCarolina",
      "Step 3: find the last name in students table",
      "Step 4: show the rows that are in the results of step 2 but not in the results of step 3"
    ],
    "primary_span": [
      [
        4,
        12
      ],
      [
        18,
        25
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ]
    ],
    "edits": [
      "distinct",
      "student enrolment"
    ],
    "edits_original": "< select > add distinct </ select > < from > add student enrolment </ from >"
  },
  {
    "question": "How much surface area do the countires in the Carribean cover together?",
    "db_id": "world_1",
    "gold_parse": "SELECT sum(SurfaceArea) FROM country WHERE Region  =  \"Caribbean\"",
    "feedback": "In step 2 , Make certain to find summation of surface area and Swap language with \"Region\".",
    "predicted_parse_with_values": "select T1.SurfaceArea from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T2.Language = \"Caribbean\"",
    "template_feedback": "in step 1 , do not use the countrylanguage table . in step 2 , consider the region equals Caribbean conditions in place of the language equals Caribbean conditions . find summation of surface area in place of surface area .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the surface area of the results of step 1 whose language equals Caribbean"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        20
      ],
      [
        30,
        34
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        21,
        29
      ],
      [
        35,
        40
      ]
    ],
    "edits": [
      "summation of surface area",
      "surface area",
      "countrylanguage",
      "region equals \"Caribbean\"",
      "language equals \"Caribbean\""
    ],
    "edits_original": "< select > add summation of surface area </ select > < select > remove surface area </ select > < from > remove countrylanguage </ from > < where > add region equals \" Caribbean \" </ where > < where > remove language equals \" Caribbean \" </ where >"
  },
  {
    "question": "What is the smallest weight of the car produced with 8 cylinders on 1974?",
    "db_id": "car_1",
    "gold_parse": "SELECT Weight FROM CARS_DATA WHERE Cylinders  =  4 AND YEAR  =  1974 ORDER BY Weight ASC LIMIT 1",
    "feedback": "Replace 1 with 1974 and also ensure cylinders equals 8",
    "predicted_parse_with_values": "select min ( Weight ) from cars_data where Year = 1",
    "template_feedback": "consider the year equals 1974 and cylinders equals 4 conditions in place of the year equals 1 conditions . find weight in place of minimum weight . find the result with the smallest weight .",
    "predicted_parse_explanation": [
      "find the minimum weight in cars data table whose year equals 1"
    ],
    "primary_span": [
      [
        0,
        9
      ],
      [
        19,
        20
      ],
      [
        27,
        34
      ]
    ],
    "secondary_span": [
      [
        10,
        18
      ],
      [
        21,
        26
      ]
    ],
    "edits": [
      "weight",
      "minimum weight",
      "cylinders equals 4",
      "year equals 1974",
      "year equals 1",
      "weight",
      "1"
    ],
    "edits_original": "< select > add weight </ select > < select > remove minimum weight </ select > < where > add cylinders equals 4 </ where > < where > add year equals 1974 </ where > < where > remove year equals 1 </ where > < orderBy > add weight </ orderBy > < limit > add 1 </ limit >"
  },
  {
    "question": "What is the most common singer citizenship?",
    "db_id": "singer",
    "gold_parse": "SELECT Citizenship FROM singer GROUP BY Citizenship ORDER BY COUNT(*) DESC LIMIT 1",
    "feedback": "Find most repetitive value of citizenship",
    "predicted_parse_with_values": "select Citizenship from singer where Name = \"singer\"",
    "template_feedback": "remove the name equals singer conditions . find for each value of citizenship . find the result with the largest number of rows .",
    "predicted_parse_explanation": [
      "find the citizenship in singer table whose name equals singer"
    ],
    "primary_span": [
      [
        0,
        6
      ],
      [
        7,
        13
      ],
      [
        14,
        23
      ]
    ],
    "secondary_span": [],
    "edits": [
      "name equals \"singer\"",
      "citizenship",
      "number of rows",
      "descending",
      "1"
    ],
    "edits_original": "< where > remove name equals \" singer \" </ where > < groupBy > add citizenship </ groupBy > < orderBy > add number of rows </ orderBy > < orderBy > add descending </ orderBy > < limit > add 1 </ limit >"
  },
  {
    "question": "Give the name of the nation that uses the greatest amount of languages.",
    "db_id": "world_1",
    "gold_parse": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name ORDER BY COUNT(*) DESC LIMIT 1",
    "feedback": "In step 1 , Supplant countrycode in countrylanguage table in place of name in country table.",
    "predicted_parse_with_values": "select Name from country group by Name order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the countrylanguage table besides the country table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of name in country table",
      "Step 2: find the name in country table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "countrylanguage"
    ],
    "edits_original": "< from > add countrylanguage </ from >"
  },
  {
    "question": "What are the ids of students who both have friends and are liked?",
    "db_id": "network_1",
    "gold_parse": "SELECT student_id FROM Friend INTERSECT SELECT liked_id FROM Likes",
    "feedback": "In step 2 , Exchange liked id of likes table with student id of friend table.",
    "predicted_parse_with_values": "select student_id from Likes intersect select liked_id from Likes",
    "template_feedback": "in step 1 , use friend table in place of likes table .",
    "predicted_parse_explanation": [
      "Step 1: find the student id in likes table",
      "Step 2: find the liked id in likes table",
      "Step 3: show the rows that are in both the results of step 1 and step 2"
    ],
    "primary_span": [
      [
        4,
        6
      ]
    ],
    "secondary_span": [
      [
        7,
        12
      ]
    ],
    "edits": [
      "friend",
      "likes"
    ],
    "edits_original": "< from > add friend </ from > < from > remove likes </ from >"
  },
  {
    "question": "how many cars were produced in 1980?",
    "db_id": "car_1",
    "gold_parse": "SELECT count(*) FROM CARS_DATA WHERE YEAR  =  1980",
    "feedback": "only use cars data , delete step 1",
    "predicted_parse_with_values": "select count ( * ) from cars_data as T1 join car_names as T2 on T1.Id = T2.MakeId where T1.Year = 1980",
    "template_feedback": "in step 1 , do not use the car names table .",
    "predicted_parse_explanation": [
      "Step 1: for each row in cars data table , find the corresponding rows in car names table",
      "Step 2: find the number of rows of the results of step 1 whose year equals 1980"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        4,
        11
      ]
    ],
    "edits": [
      "car names"
    ],
    "edits_original": "< from > remove car names </ from >"
  },
  {
    "question": "How many paragraphs for the document with name 'Summer Show'?",
    "db_id": "cre_Doc_Template_Mgt",
    "gold_parse": "SELECT count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_ID  =  T2.document_ID WHERE T2.document_name  =  'Summer Show'",
    "feedback": "Supersede documents table\" with paragraphs table\" and assure correspondence.",
    "predicted_parse_with_values": "select count ( * ) from Documents where Document_Name = \"Summer Show\"",
    "template_feedback": "additionally use the information from the paragraphs table besides the documents table .",
    "predicted_parse_explanation": [
      "find the number of rows in documents table whose document name equals Summer Show"
    ],
    "primary_span": [
      [
        0,
        7
      ]
    ],
    "secondary_span": [
      [
        8,
        12
      ]
    ],
    "edits": [
      "paragraphs"
    ],
    "edits_original": "< from > add paragraphs </ from >"
  },
  {
    "question": "What are the first names of all players, and their average rankings?",
    "db_id": "wta_1",
    "gold_parse": "SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",
    "feedback": "Interchange rankings 's player id with players 's first name hand ranking points with rankings in step 2.",
    "predicted_parse_with_values": "select T1.first_name , avg ( T2.ranking_points ) from players as T1 join rankings as T2 on T1.player_id = T2.player_id group by T2.player_id",
    "template_feedback": "in step 2 , find for each value of first name in place of rankings 's player id . find average ranking in place of average ranking points .",
    "predicted_parse_explanation": [
      "Step 1: for each row in players table , find the corresponding rows in rankings table",
      "Step 2: find each value of rankings 's player id of the results of step 1 along with the first name and average ranking points of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        19,
        21
      ]
    ],
    "secondary_span": [
      [
        11,
        18
      ],
      [
        22,
        28
      ]
    ],
    "edits": [
      "average ranking",
      "average ranking points",
      "first name",
      "player id"
    ],
    "edits_original": "< select > add average ranking </ select > < select > remove average ranking points </ select > < groupBy > add first name </ groupBy > < groupBy > remove player id </ groupBy >"
  },
  {
    "question": "Show paragraph details for paragraph with text 'Korea'.",
    "db_id": "cre_Doc_Template_Mgt",
    "gold_parse": "SELECT Other_Details FROM Paragraphs WHERE paragraph_text  =  'Korea'",
    "feedback": "Supplant first paragraph text with other details",
    "predicted_parse_with_values": "select Paragraph_Text from Paragraphs where Paragraph_Text = \"Korea\"",
    "template_feedback": "find other details in place of paragraph text .",
    "predicted_parse_explanation": [
      "find the paragraph text in paragraphs table whose paragraph text equals Korea"
    ],
    "primary_span": [
      [
        0,
        2
      ]
    ],
    "secondary_span": [
      [
        3,
        8
      ]
    ],
    "edits": [
      "other details",
      "paragraph text"
    ],
    "edits_original": "< select > add other details </ select > < select > remove paragraph text </ select >"
  },
  {
    "question": "Find the number of dog pets that are raised by female students (with sex F).",
    "db_id": "pets_1",
    "gold_parse": "SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T2.petid  =  T3.petid WHERE T1.sex  =  'F' AND T3.pettype  =  'dog'",
    "feedback": "Ensure corresponding student id present in has pet table and corresponding pets 's pet type equals dog.",
    "predicted_parse_with_values": "select count ( * ) from Student where Sex = \"F\"",
    "template_feedback": "additionally use the information from the pets table and has pet table besides the student table . additionally make sure that pet type equals dog .",
    "predicted_parse_explanation": [
      "find the number of rows in student table whose sex equals F"
    ],
    "primary_span": [
      [
        0,
        11
      ],
      [
        17,
        25
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "has pet",
      "pets",
      "pet type equals \"dog\""
    ],
    "edits_original": "< from > add has pet </ from > < from > add pets </ from > < where > add pet type equals \" dog \" </ where >"
  },
  {
    "question": "List the name and tonnage ordered by in descending alphaetical order for the names.",
    "db_id": "battle_death",
    "gold_parse": "SELECT name ,  tonnage FROM ship ORDER BY name DESC",
    "feedback": "Need to order descending by name and note by tonnage",
    "predicted_parse_with_values": "select name , tonnage from ship order by tonnage desc",
    "template_feedback": "order the results by name in place of tonnage .",
    "predicted_parse_explanation": [
      "find the name and tonnage in ship table ordered descending by tonnage"
    ],
    "primary_span": [
      [
        0,
        4
      ]
    ],
    "secondary_span": [
      [
        5,
        9
      ]
    ],
    "edits": [
      "name",
      "tonnage"
    ],
    "edits_original": "< orderBy > add name </ orderBy > < orderBy > remove tonnage </ orderBy >"
  },
  {
    "question": "Show names of teachers that teach at least two courses.",
    "db_id": "course_teach",
    "gold_parse": "SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*)  >=  2",
    "feedback": "In step 1 , Supersede  name in teacher table ' with  teacher id in course arrange table '.",
    "predicted_parse_with_values": "select Name from teacher group by Name having count ( * ) > = 2",
    "template_feedback": "in step 1 , additionally use the information from the course arrange table besides the teacher table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of name in teacher table",
      "Step 2: find the name in teacher table whose corresponding value in step 1 is greater than or equals 2"
    ],
    "primary_span": [
      [
        4,
        12
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ]
    ],
    "edits": [
      "course arrange"
    ],
    "edits_original": "< from > add course arrange </ from >"
  },
  {
    "question": "How many official languages are spoken in Afghanistan?",
    "db_id": "world_1",
    "gold_parse": "SELECT COUNT(*) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Afghanistan\" AND IsOfficial  =  \"T\"",
    "feedback": "In step 2 , Supplant region with \"Name\".",
    "predicted_parse_with_values": "select count ( T2.Language ) from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T1.Region = \"Afghanistan\"",
    "template_feedback": "in step 2 , consider the is official equals T and name equals Afghanistan conditions in place of the region equals Afghanistan conditions . find number of rows in place of number of language .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the number of language of the results of step 1 whose region equals Afghanistan"
    ],
    "primary_span": [
      [
        4,
        14
      ],
      [
        24,
        27
      ]
    ],
    "secondary_span": [
      [
        15,
        23
      ],
      [
        28,
        34
      ]
    ],
    "edits": [
      "number of rows",
      "number of language",
      "name equals \"Afghanistan\"",
      "is official equals \"T\"",
      "region equals \"Afghanistan\""
    ],
    "edits_original": "< select > add number of rows </ select > < select > remove number of language </ select > < where > add name equals \" Afghanistan \" </ where > < where > add is official equals \" T \" </ where > < where > remove region equals \" Afghanistan \" </ where >"
  },
  {
    "question": "What is the id, line 1, and line 2 of the address with the most students?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1",
    "feedback": "Interchange address id in addresses table with current address id in students table in step 1.",
    "predicted_parse_with_values": "select address_id , line_1 , line_2 from Addresses group by address_id order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the students table besides the addresses table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of address id in addresses table",
      "Step 2: find the address id , line 1 , line 2 in addresses table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "students"
    ],
    "edits_original": "< from > add students </ from >"
  },
  {
    "question": "How many countries does each continent have? List the continent id, continent name and the number of countries.",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.ContId ,  T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.Continent GROUP BY T1.ContId",
    "feedback": "Replace second continents with cont id in step 2.",
    "predicted_parse_with_values": "select T1.Continent , T2.Continent , count ( * ) from continents as T1 join countries as T2 on T1.ContId = T2.Continent group by T1.Continent",
    "template_feedback": "in step 2 , find for each value of cont id in place of continents 's continent .",
    "predicted_parse_explanation": [
      "Step 1: for each row in continents table , find the corresponding rows in countries table",
      "Step 2: find each value of continents 's continent of the results of step 1 along with the number of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        4,
        10
      ]
    ],
    "secondary_span": [
      [
        11,
        17
      ]
    ],
    "edits": [
      "cont id",
      "continent",
      "cont id",
      "continent"
    ],
    "edits_original": "< select > add cont id </ select > < select > remove continent </ select > < groupBy > add cont id </ groupBy > < groupBy > remove continent </ groupBy >"
  },
  {
    "question": "What is the total ticket expense of the visitors whose membership level is 1?",
    "db_id": "museum_visit",
    "gold_parse": "SELECT sum(t2.Total_spent) FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id WHERE t1.Level_of_membership  =  1",
    "feedback": "In step 2 , Substitute num of ticket with total spent",
    "predicted_parse_with_values": "select sum ( T2.Num_of_Ticket ) from visitor as T1 join visit as T2 on T1.ID = T2.visitor_ID where T1.Level_of_membership = 1",
    "template_feedback": "in step 2 , find summation of total spent in place of summation of num of ticket .",
    "predicted_parse_explanation": [
      "Step 1: for each row in customer table , find the corresponding rows in visit table",
      "Step 2: find the summation of num of ticket of the results of step 1 whose level of membership equals 1"
    ],
    "primary_span": [
      [
        4,
        8
      ]
    ],
    "secondary_span": [
      [
        9,
        17
      ]
    ],
    "edits": [
      "summation of total spent",
      "summation of num of ticket"
    ],
    "edits_original": "< select > add summation of total spent </ select > < select > remove summation of num of ticket </ select >"
  },
  {
    "question": "Which airlines have a flight with source airport AHD?",
    "db_id": "flight_2",
    "gold_parse": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"AHD\"",
    "feedback": "don 't repeat airlines",
    "predicted_parse_with_values": "select Airline from flights where SourceAirport = \"AHD\"",
    "template_feedback": "additionally use the information from the airlines table besides the flights table . find airlines 's airline name in place of flights 's airline .",
    "predicted_parse_explanation": [
      "find the airline in flights table whose source airport equals AHD"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        13,
        17
      ]
    ],
    "secondary_span": [
      [
        8,
        12
      ],
      [
        18,
        24
      ]
    ],
    "edits": [
      "airline name",
      "airline",
      "airlines"
    ],
    "edits_original": "< select > add airline name </ select > < select > remove airline </ select > < from > add airlines </ from >"
  },
  {
    "question": "Find the name, population and expected life length of asian country with the largest area?",
    "db_id": "world_1",
    "gold_parse": "SELECT Name ,  Population ,  LifeExpectancy FROM country WHERE Continent  =  \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1",
    "feedback": "Make sure continent equals Asia and interchange second life expectancy with surface area",
    "predicted_parse_with_values": "select Name , Population , LifeExpectancy from country order by LifeExpectancy desc limit 1",
    "template_feedback": "additionally make sure that continent equals Asia . order the results by surface area in place of life expectancy .",
    "predicted_parse_explanation": [
      "find the name , population , life expectancy in country table with largest value of life expectancy"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        8,
        13
      ]
    ],
    "secondary_span": [
      [
        14,
        19
      ]
    ],
    "edits": [
      "continent equals \"Asia\"",
      "surface area",
      "life expectancy"
    ],
    "edits_original": "< where > add continent equals \" Asia \" </ where > < orderBy > add surface area </ orderBy > < orderBy > remove life expectancy </ orderBy >"
  },
  {
    "question": "How many battles did not lose any ship with tonnage '225'?",
    "db_id": "battle_death",
    "gold_parse": "SELECT count(*) FROM battle WHERE id NOT IN ( SELECT lost_in_battle FROM ship WHERE tonnage  =  '225' )",
    "feedback": "in step 1 , replace id with lost in battle",
    "predicted_parse_with_values": "select count ( * ) from battle where id not in ( select id from ship where tonnage = '225' )",
    "template_feedback": "in step 1 , find lost in battle in place of ship 's id .",
    "predicted_parse_explanation": [
      "Step 1: find the ship 's id in ship table whose tonnage equals 225",
      "Step 2: find the number of rows in battle table whose battle 's id not one of the results of step 1"
    ],
    "primary_span": [
      [
        4,
        7
      ]
    ],
    "secondary_span": [
      [
        8,
        14
      ]
    ],
    "edits": [
      "lost in battle",
      "id"
    ],
    "edits_original": "< select > add lost in battle </ select > < select > remove id </ select >"
  },
  {
    "question": "Return the version numbers and template type codes of templates with a version number greater than 5.",
    "db_id": "cre_Doc_Template_Mgt",
    "gold_parse": "SELECT version_number ,  template_type_code FROM Templates WHERE version_number  >  5",
    "feedback": "Swap date effective from with version number",
    "predicted_parse_with_values": "select Version_Number , Template_Type_Code from Templates where Date_Effective_To > 5",
    "template_feedback": "consider the version number greater than 5 conditions in place of the date effective to greater than 5 conditions .",
    "predicted_parse_explanation": [
      "find the version number and template type code in templates table whose date effective to greater than 5"
    ],
    "primary_span": [
      [
        0,
        7
      ]
    ],
    "secondary_span": [
      [
        8,
        19
      ]
    ],
    "edits": [
      "version number greater than 5",
      "date effective to greater than 5"
    ],
    "edits_original": "< where > add version number greater than 5 </ where > < where > remove date effective to greater than 5 </ where >"
  },
  {
    "question": "Count the number of flights departing from 'APG'.",
    "db_id": "flight_2",
    "gold_parse": "SELECT count(*) FROM FLIGHTS WHERE SourceAirport  =  \"APG\"",
    "feedback": "In step 2 , Replace airport name with source airport",
    "predicted_parse_with_values": "select count ( * ) from flights as T1 join airports as T2 on T1.DestAirport = T2.AirportCode where T2.AirportName = \"APG\"",
    "template_feedback": "in step 1 , do not use the airports table . in step 2 , consider the source airport equals APG conditions in place of the airport name equals APG conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in flights table , find the corresponding rows in airports table",
      "Step 2: find the number of rows of the results of step 1 whose airport name equals APG"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        21
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        22,
        31
      ]
    ],
    "edits": [
      "airports",
      "source airport equals \"APG\"",
      "airport name equals \"APG\""
    ],
    "edits_original": "< from > remove airports </ from > < where > add source airport equals \" APG \" </ where > < where > remove airport name equals \" APG \" </ where >"
  },
  {
    "question": "What are the record companies that are used by both orchestras founded before 2003 and those founded after 2003?",
    "db_id": "orchestra",
    "gold_parse": "SELECT Record_Company FROM orchestra WHERE Year_of_Founded  <  2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded  >  2003",
    "feedback": "Supersede \"greater\" with \"less\" in step 2.",
    "predicted_parse_with_values": "select Record_Company from orchestra where Year_of_Founded > 2003 intersect select Record_Company from orchestra where Year_of_Founded > 2003",
    "template_feedback": "in step 1 , consider the year of founded less than 2003 conditions in place of the year of founded greater than 2003 conditions .",
    "predicted_parse_explanation": [
      "Step 1: find the record company in orchestra table whose year of founded greater than 2003",
      "Step 2: find the record company in orchestra table whose year of founded greater than 2003",
      "Step 3: show the rows that are in both the results of step 1 and step 2"
    ],
    "primary_span": [
      [
        4,
        12
      ]
    ],
    "secondary_span": [
      [
        13,
        24
      ]
    ],
    "edits": [
      "year of founded less than 2003",
      "year of founded greater than 2003"
    ],
    "edits_original": "< where > add year of founded less than 2003 </ where > < where > remove year of founded greater than 2003 </ where >"
  },
  {
    "question": "How many 'United Airlines' flights depart from Airport 'AHD'?",
    "db_id": "flight_2",
    "gold_parse": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.SourceAirport  =  \"AHD\"",
    "feedback": "Find count of flights 's airlines whose (corresponding)airlines 's airlines equals United airlines , and source airport equals AHD.",
    "predicted_parse_with_values": "select count ( * ) from airports where AirportName = \"AHD\"",
    "template_feedback": "use flights table and airlines table in place of airports table . consider the source airport equals AHD and airlines 's airline name equals United Airlines conditions in place of the airport name equals AHD conditions .",
    "predicted_parse_explanation": [
      "find the number of rows in airports table whose airport name equals AHD"
    ],
    "primary_span": [
      [
        0,
        5
      ],
      [
        12,
        26
      ]
    ],
    "secondary_span": [
      [
        6,
        11
      ],
      [
        27,
        36
      ]
    ],
    "edits": [
      "airlines",
      "flights",
      "airports",
      "airline name equals \"United Airlines\"",
      "source airport equals \"AHD\"",
      "airport name equals \"AHD\""
    ],
    "edits_original": "< from > add airlines </ from > < from > add flights </ from > < from > remove airports </ from > < where > add airline name equals \" United Airlines \" </ where > < where > add source airport equals \" AHD \" </ where > < where > remove airport name equals \" AHD \" </ where >"
  },
  {
    "question": "How much does the most recent treatment cost?",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1",
    "feedback": "Switch second  cost of treatment with  date of treatment",
    "predicted_parse_with_values": "select cost_of_treatment from Treatments order by cost_of_treatment desc limit 1",
    "template_feedback": "order the results by date of treatment in place of cost of treatment .",
    "predicted_parse_explanation": [
      "find the cost of treatment in treatments table with largest value of cost of treatment"
    ],
    "primary_span": [
      [
        0,
        6
      ]
    ],
    "secondary_span": [
      [
        7,
        13
      ]
    ],
    "edits": [
      "date of treatment",
      "cost of treatment"
    ],
    "edits_original": "< orderBy > add date of treatment </ orderBy > < orderBy > remove cost of treatment </ orderBy >"
  },
  {
    "question": "What is the date and id of the transcript with at least 2 courses listed?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*)  >=  2",
    "feedback": "Step 1 , Switch transcripts table with transcript contents table. Step 2 , Switch transcript date with transcript id",
    "predicted_parse_with_values": "select transcript_date , transcript_date from Transcripts group by transcript_id having count ( * ) > = 2",
    "template_feedback": "in step 1 , additionally use the information from the transcript contents table besides the transcripts table . in step 2 , additionally find transcript contents 's transcript id .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of transcript id in transcripts table",
      "Step 2: find the transcript date and transcript date in transcripts table whose corresponding value in step 1 is greater than or equals 2"
    ],
    "primary_span": [
      [
        4,
        12
      ],
      [
        22,
        29
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ]
    ],
    "edits": [
      "transcript id",
      "transcript date",
      "transcript contents"
    ],
    "edits_original": "< select > add transcript id </ select > < select > remove transcript date </ select > < from > add transcript contents </ from >"
  },
  {
    "question": "Show the ids of high schoolers who have friends and are also liked by someone else.",
    "db_id": "network_1",
    "gold_parse": "SELECT student_id FROM Friend INTERSECT SELECT liked_id FROM Likes",
    "feedback": "(Step 1)Ensure corresponding student id present in friend table; (Step 2)Ensure corresponding student id present in likes table.",
    "predicted_parse_with_values": "select ID from Highschooler intersect select ID from Highschooler",
    "template_feedback": "in step 1 , use friend table in place of high schooler table . in step 2 , use likes table in place of high schooler table .",
    "predicted_parse_explanation": [
      "Step 1: find the id in high schooler table",
      "Step 2: find the id in high schooler table",
      "Step 3: show the rows that are in both the results of step 1 and step 2"
    ],
    "primary_span": [
      [
        4,
        6
      ],
      [
        18,
        20
      ]
    ],
    "secondary_span": [
      [
        7,
        13
      ],
      [
        21,
        27
      ]
    ],
    "edits": [
      "student id",
      "id",
      "friend",
      "high schooler",
      "liked id",
      "id",
      "likes",
      "high schooler"
    ],
    "edits_original": "< select > add student id </ select > < select > remove id </ select > < from > add friend </ from > < from > remove high schooler </ from > < select > add liked id </ select > < select > remove id </ select > < from > add likes </ from > < from > remove high schooler </ from >"
  },
  {
    "question": "What are the distinct template type descriptions for the templates ever used by any document?",
    "db_id": "cre_Doc_Template_Mgt",
    "gold_parse": "SELECT DISTINCT T1.template_type_description FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code JOIN Documents AS T3 ON T2.Template_ID  =  T3.template_ID",
    "feedback": "Find without repetition template type description , and make sure its corresponding template id present in documents table.",
    "predicted_parse_with_values": "select Template_Type_Description from Ref_Template_Types",
    "template_feedback": "additionally use the information from the documents table and templates table besides the reference template types table . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "find the template type description in reference template types table"
    ],
    "primary_span": [
      [
        0,
        10
      ],
      [
        18,
        25
      ]
    ],
    "secondary_span": [
      [
        11,
        17
      ]
    ],
    "edits": [
      "distinct",
      "templates",
      "documents"
    ],
    "edits_original": "< select > add distinct </ select > < from > add templates </ from > < from > add documents </ from >"
  },
  {
    "question": "Count the number of paragraphs in the document named 'Summer Show'.",
    "db_id": "cre_Doc_Template_Mgt",
    "gold_parse": "SELECT count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_ID  =  T2.document_ID WHERE T2.document_name  =  'Summer Show'",
    "feedback": "Find number of rows in paragraphs table whose document id 's (corresponding)Documents 's document name equals Summer Show",
    "predicted_parse_with_values": "select count ( * ) from Documents where Document_Name = \"Summer Show\"",
    "template_feedback": "additionally use the information from the paragraphs table besides the documents table .",
    "predicted_parse_explanation": [
      "find the number of rows in documents table whose document name equals Summer Show"
    ],
    "primary_span": [
      [
        0,
        7
      ]
    ],
    "secondary_span": [
      [
        8,
        12
      ]
    ],
    "edits": [
      "paragraphs"
    ],
    "edits_original": "< from > add paragraphs </ from >"
  },
  {
    "question": "How many flights depart from 'APG'?",
    "db_id": "flight_2",
    "gold_parse": "SELECT count(*) FROM FLIGHTS WHERE SourceAirport  =  \"APG\"",
    "feedback": "Change country with source airport in step 2.",
    "predicted_parse_with_values": "select count ( * ) from flights as T1 join airports as T2 on T1.DestAirport = T2.AirportCode where T2.Country = \"APG\"",
    "template_feedback": "in step 1 , do not use the airports table . in step 2 , consider the source airport equals APG conditions in place of the country equals APG conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in flights table , find the corresponding rows in airports table",
      "Step 2: find the number of rows of the results of step 1 whose country equals APG"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        21
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        22,
        30
      ]
    ],
    "edits": [
      "airports",
      "source airport equals \"APG\"",
      "country equals \"APG\""
    ],
    "edits_original": "< from > remove airports </ from > < where > add source airport equals \" APG \" </ where > < where > remove country equals \" APG \" </ where >"
  },
  {
    "question": "What are the cost and treatment type description of each treatment?",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT T1.cost_of_treatment ,  T2.treatment_type_description FROM Treatments AS T1 JOIN treatment_types AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code",
    "feedback": "Instead of treatment type code find treatment type code 's corresponding treatment types 's treatment type description",
    "predicted_parse_with_values": "select cost_of_treatment , treatment_type_code from Treatments",
    "template_feedback": "additionally use the information from the treatment types table besides the treatments table . find treatment type description in place of treatments 's treatment type code .",
    "predicted_parse_explanation": [
      "find the cost of treatment and treatment type code in treatments table"
    ],
    "primary_span": [
      [
        0,
        8
      ],
      [
        14,
        17
      ]
    ],
    "secondary_span": [
      [
        9,
        13
      ],
      [
        18,
        26
      ]
    ],
    "edits": [
      "treatment type description",
      "treatment type code",
      "treatment types"
    ],
    "edits_original": "< select > add treatment type description </ select > < select > remove treatment type code </ select > < from > add treatment types </ from >"
  },
  {
    "question": "What is the code of airport that has the highest number of flights?",
    "db_id": "flight_2",
    "gold_parse": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1",
    "feedback": "Correspond airports with flights and find airport code which has highest number of rows per airport code",
    "predicted_parse_with_values": "select AirportCode from airports group by AirportCode order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the flights table besides the airports table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of airport code in airports table",
      "Step 2: find the airport code in airports table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "flights"
    ],
    "edits_original": "< from > add flights </ from >"
  },
  {
    "question": "What are the names and ids of all makers with more than 3 models?",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3",
    "feedback": "Replace id in car makers table with maker in model list table(step 1); Replace first id with FullName(step 2).",
    "predicted_parse_with_values": "select Id , Id from car_makers group by Id having count ( * ) > 3",
    "template_feedback": "in step 1 , additionally use the information from the model list table besides the car makers table . in step 2 , additionally find full name .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of id in car makers table",
      "Step 2: find the id and id in car makers table whose corresponding value in step 1 is greater than 3"
    ],
    "primary_span": [
      [
        4,
        12
      ],
      [
        23,
        27
      ]
    ],
    "secondary_span": [
      [
        13,
        18
      ]
    ],
    "edits": [
      "full name",
      "id",
      "model list"
    ],
    "edits_original": "< select > add full name </ select > < select > remove id </ select > < from > add model list </ from >"
  },
  {
    "question": "Which countries have greater area than that of any country in Europe?",
    "db_id": "world_1",
    "gold_parse": "SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  \"Europe\")",
    "feedback": "In step 1 , Supplant region with continent In step 2 , Supplant continent with \"Name\".",
    "predicted_parse_with_values": "select Continent from country where SurfaceArea > ( select max ( SurfaceArea ) from country where Region = \"Europe\" )",
    "template_feedback": "in step 1 , consider the continent equals Europe conditions in place of the region equals Europe conditions . find minimum surface area in place of maximum surface area . in step 2 , find name in place of continent .",
    "predicted_parse_explanation": [
      "Step 1: find the maximum surface area in country table whose region equals Europe",
      "Step 2: find the continent in country table whose surface area greater than the results of step 1"
    ],
    "primary_span": [
      [
        4,
        9
      ],
      [
        19,
        22
      ],
      [
        34,
        35
      ]
    ],
    "secondary_span": [
      [
        10,
        18
      ],
      [
        23,
        29
      ],
      [
        36,
        40
      ]
    ],
    "edits": [
      "name",
      "continent",
      "minimum surface area",
      "maximum surface area",
      "continent equals \"Europe\"",
      "region equals \"Europe\""
    ],
    "edits_original": "< select > add name </ select > < select > remove continent </ select > < select > add minimum surface area </ select > < select > remove maximum surface area </ select > < where > add continent equals \" Europe \" </ where > < where > remove region equals \" Europe \" </ where >"
  },
  {
    "question": "What is the number of cars with more than 4 cylinders?",
    "db_id": "car_1",
    "gold_parse": "SELECT count(*) FROM CARS_DATA WHERE Cylinders  >  4",
    "feedback": "remove step 1 and only use cars data in step 2",
    "predicted_parse_with_values": "select count ( * ) from cars_data as T1 join car_names as T2 on T1.Id = T2.MakeId where T1.Cylinders > 4",
    "template_feedback": "in step 1 , do not use the car names table .",
    "predicted_parse_explanation": [
      "Step 1: for each row in cars data table , find the corresponding rows in car names table",
      "Step 2: find the number of rows of the results of step 1 whose cylinders greater than 4"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        4,
        11
      ]
    ],
    "edits": [
      "car names"
    ],
    "edits_original": "< from > remove car names </ from >"
  },
  {
    "question": "What model has the most different versions?",
    "db_id": "car_1",
    "gold_parse": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1",
    "feedback": "Interchange model list table with car names in step 1.",
    "predicted_parse_with_values": "select Model from model_list group by Model order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , use car names table in place of model list table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of model in model list table",
      "Step 2: find the model in model list table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        7
      ]
    ],
    "secondary_span": [
      [
        8,
        14
      ]
    ],
    "edits": [
      "car names",
      "model list"
    ],
    "edits_original": "< from > add car names </ from > < from > remove model list </ from >"
  },
  {
    "question": "Give the country codes for countries in which people speak langauges that are not English.",
    "db_id": "world_1",
    "gold_parse": "SELECT DISTINCT CountryCode FROM countrylanguage WHERE LANGUAGE != \"English\"",
    "feedback": "don 't repeat code in the output result",
    "predicted_parse_with_values": "select T1.Code from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T2.Language != \"English\"",
    "template_feedback": "in step 1 , do not use the country table . in step 2 , make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the code of the results of step 1 whose language not equals English"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        22
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ]
    ],
    "edits": [
      "distinct",
      "countrycode",
      "code",
      "country"
    ],
    "edits_original": "< select > add distinct </ select > < select > add countrycode </ select > < select > remove code </ select > < from > remove country </ from >"
  },
  {
    "question": "Give the names of countries that are in Europe and have a population equal to 80000.",
    "db_id": "world_1",
    "gold_parse": "SELECT Name FROM country WHERE continent  =  \"Europe\" AND Population  =  \"80000\"",
    "feedback": "Get name of country table where continent equals Europe and population equals 80000.",
    "predicted_parse_with_values": "select Name from country where Population >= \"80000\" and Population <= \"80000\"",
    "template_feedback": "consider the population equals 80000 and continent equals Europe conditions in place of the population greater than or equals 80000 and population less than or equals 80000 conditions .",
    "predicted_parse_explanation": [
      "find the name in country table whose population greater than or equals 80000 and population less than or equals 80000"
    ],
    "primary_span": [
      [
        0,
        9
      ]
    ],
    "secondary_span": [
      [
        10,
        28
      ]
    ],
    "edits": [
      "continent equals \"Europe\"",
      "population equals \"80000\"",
      "population greater than or equals to \"80000\"",
      "population less than or equals to \"80000\""
    ],
    "edits_original": "< where > add continent equals \" Europe \" </ where > < where > add population equals \" 80000 \" </ where > < where > remove population greater than or equals to \" 80000 \" </ where > < where > remove population less than or equals to \" 80000 \" </ where >"
  },
  {
    "question": "What are the names of all courses that have some students enrolled?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT DISTINCT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id",
    "feedback": "Ensure corresponding course id present in student enrolment courses table.",
    "predicted_parse_with_values": "select course_name from Courses",
    "template_feedback": "additionally use the information from the student enrolment courses table besides the courses table . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "find the course name in courses table"
    ],
    "primary_span": [
      [
        0,
        9
      ],
      [
        15,
        22
      ]
    ],
    "secondary_span": [
      [
        10,
        14
      ]
    ],
    "edits": [
      "distinct",
      "student enrolment courses"
    ],
    "edits_original": "< select > add distinct </ select > < from > add student enrolment courses </ from >"
  },
  {
    "question": "What are airlines that have flights arriving at airport 'AHD'?",
    "db_id": "flight_2",
    "gold_parse": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.DestAirport  =  \"AHD\"",
    "feedback": "In step 1 , Change airports with \"flights\". In step 2 , Change airport name with destination airport",
    "predicted_parse_with_values": "select T2.Airline from airports as T1 join airlines as T2 where T1.AirportName = \"AHD\"",
    "template_feedback": "in step 1 , use flights table in place of airports table in step 2 , consider the destination airport equals AHD conditions in place of the airport name equals AHD conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in airports table , find the corresponding rows in airlines table",
      "Step 2: find the airline name of the results of step 1 whose airport name equals AHD"
    ],
    "primary_span": [
      [
        4,
        6
      ],
      [
        16,
        22
      ]
    ],
    "secondary_span": [
      [
        7,
        11
      ],
      [
        23,
        32
      ]
    ],
    "edits": [
      "flights",
      "airports",
      "destination airport equals \"AHD\"",
      "airport name equals \"AHD\""
    ],
    "edits_original": "< from > add flights </ from > < from > remove airports </ from > < where > add destination airport equals \" AHD \" </ where > < where > remove airport name equals \" AHD \" </ where >"
  },
  {
    "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?",
    "db_id": "wta_1",
    "gold_parse": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1",
    "feedback": "Replace winner rank with summation of winner rank points , hand winner rank points with number of rows of value of winner name",
    "predicted_parse_with_values": "select winner_name , winner_rank from matches order by winner_rank_points desc limit 1",
    "template_feedback": "find for each value of winner name . find winner rank points in place of winner rank . order the results by number of rows in place of winner rank points .",
    "predicted_parse_explanation": [
      "find the winner name and winner rank in matches table with largest value of winner rank points"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        8,
        11
      ],
      [
        18,
        24
      ]
    ],
    "secondary_span": [
      [
        12,
        17
      ],
      [
        25,
        31
      ]
    ],
    "edits": [
      "winner rank points",
      "winner rank",
      "winner name",
      "number of rows",
      "winner rank points"
    ],
    "edits_original": "< select > add winner rank points </ select > < select > remove winner rank </ select > < groupBy > add winner name </ groupBy > < orderBy > add number of rows </ orderBy > < orderBy > remove winner rank points </ orderBy >"
  },
  {
    "question": "Which airlines have departing flights from both APG and CVO airports?",
    "db_id": "flight_2",
    "gold_parse": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\" INTERSECT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\"",
    "feedback": "Step 1 , Change  airports with  airlines In both Step 2 and 3 change  airport name with  source airport",
    "predicted_parse_with_values": "select T1.Airline from flights as T1 join airports as T2 on T1.DestAirport = T2.AirportCode where T2.AirportName = \"APG\" intersect select T3.Airline from flights as T3 join airports as T4 on T3.DestAirport = T4.AirportCode where T4.AirportName = \"CVO\"",
    "template_feedback": "in step 1 , use airlines table in place of airports table in step 2 , consider the source airport equals APG conditions in place of the airport name equals APG conditions . find airlines 's airline name in place of flights 's airline . in step 3 , use airlines table in place of airports table in step 4 , consider the source airport equals CVO conditions in place of the airport name equals CVO conditions . find airlines 's airline name in place of flights 's airline .",
    "predicted_parse_explanation": [
      "Step 1: for each row in flights table , find the corresponding rows in airports table",
      "Step 2: find the airline of the results of step 1 whose airport name equals APG",
      "Step 3: for each row in flights table , find the corresponding rows in airports table",
      "Step 4: find the airline of the results of step 3 whose airport name equals CVO",
      "Step 5: show the rows that are in both the results of step 2 and step 4"
    ],
    "primary_span": [
      [
        4,
        6
      ],
      [
        16,
        22
      ],
      [
        33,
        37
      ],
      [
        49,
        51
      ],
      [
        61,
        67
      ],
      [
        78,
        82
      ]
    ],
    "secondary_span": [
      [
        7,
        11
      ],
      [
        23,
        32
      ],
      [
        38,
        44
      ],
      [
        52,
        56
      ],
      [
        68,
        77
      ],
      [
        83,
        89
      ]
    ],
    "edits": [
      "airline name",
      "airline",
      "airlines",
      "airports",
      "source airport equals \"APG\"",
      "airport name equals \"APG\"",
      "airline name",
      "airline",
      "airlines",
      "airports",
      "source airport equals \"CVO\"",
      "airport name equals \"CVO\""
    ],
    "edits_original": "< select > add airline name </ select > < select > remove airline </ select > < from > add airlines </ from > < from > remove airports </ from > < where > add source airport equals \" APG \" </ where > < where > remove airport name equals \" APG \" </ where > < select > add airline name </ select > < select > remove airline </ select > < from > add airlines </ from > < from > remove airports </ from > < where > add source airport equals \" CVO \" </ where > < where > remove airport name equals \" CVO \" </ where >"
  },
  {
    "question": "How many times at most can a course enrollment result show in different transcripts? Also show the course enrollment id.",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1",
    "feedback": "In step 2 , Ensure to show each value of different transcript id , show student course id as well.",
    "predicted_parse_with_values": "select transcript_id , count ( * ) from Transcripts group by transcript_id order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , use transcript contents table in place of transcripts table . find for each value of student course id in place of transcripts 's transcript id . in step 2 , find student course id in place of transcripts 's transcript id .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of transcript id in transcripts table",
      "Step 2: find the transcript id and number of rows in transcripts table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        7
      ],
      [
        14,
        21
      ],
      [
        34,
        37
      ]
    ],
    "secondary_span": [
      [
        8,
        13
      ],
      [
        22,
        29
      ],
      [
        38,
        45
      ]
    ],
    "edits": [
      "student course id",
      "transcript id",
      "transcript contents",
      "transcripts",
      "student course id",
      "transcript id"
    ],
    "edits_original": "< select > add student course id </ select > < select > remove transcript id </ select > < from > add transcript contents </ from > < from > remove transcripts </ from > < groupBy > add student course id </ groupBy > < groupBy > remove transcript id </ groupBy >"
  },
  {
    "question": "For the cars with 4 cylinders, which model has the largest horsepower?",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1",
    "feedback": "Supersede \"Id\" with \"corresponding car names 's Model\".",
    "predicted_parse_with_values": "select Id from cars_data where Cylinders = 4 order by Horsepower desc limit 1",
    "template_feedback": "additionally use the information from the car names table besides the cars data table . find model in place of id .",
    "predicted_parse_explanation": [
      "find the id in cars data table whose cylinders equals 4 with largest value of horsepower"
    ],
    "primary_span": [
      [
        0,
        8
      ],
      [
        15,
        16
      ]
    ],
    "secondary_span": [
      [
        9,
        14
      ],
      [
        17,
        21
      ]
    ],
    "edits": [
      "model",
      "id",
      "car names"
    ],
    "edits_original": "< select > add model </ select > < select > remove id </ select > < from > add car names </ from >"
  },
  {
    "question": "Show names of teachers and the number of courses they teach.",
    "db_id": "course_teach",
    "gold_parse": "SELECT T2.Name ,  COUNT(*) FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name",
    "feedback": "Should corresponds to number of rows of each value of teacher id in course arrange table.",
    "predicted_parse_with_values": "select Name , count ( * ) from teacher group by Name",
    "template_feedback": "additionally use the information from the course arrange table besides the teacher table .",
    "predicted_parse_explanation": [
      "find each value of name in teacher table along with the number of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        0,
        8
      ]
    ],
    "secondary_span": [
      [
        9,
        13
      ]
    ],
    "edits": [
      "course arrange"
    ],
    "edits_original": "< from > add course arrange </ from >"
  },
  {
    "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2",
    "feedback": "Interchange students with student enrolment and ensure to find for same semester id(step 1); Also find id(step 2).",
    "predicted_parse_with_values": "select first_name , middle_name , last_name from Students group by student_id having count ( * ) = 2",
    "template_feedback": "in step 1 , additionally use the information from the student enrolment table besides the students table . in step 2 , additionally find students 's student id .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of student id in students table",
      "Step 2: find the first name , middle name , last name in students table whose corresponding value in step 1 is equals 2"
    ],
    "primary_span": [
      [
        4,
        12
      ],
      [
        22,
        28
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ]
    ],
    "edits": [
      "student id",
      "student enrolment"
    ],
    "edits_original": "< select > add student id </ select > < from > add student enrolment </ from >"
  },
  {
    "question": "Count the number of friends Kyle has.",
    "db_id": "network_1",
    "gold_parse": "SELECT count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"",
    "feedback": "Count rows in friend table for student id whose corresponding name in high schooler table is Kyle.",
    "predicted_parse_with_values": "select count ( * ) from Friend where friend_id = \"Kyle\"",
    "template_feedback": "additionally use the information from the high schooler table besides the friend table . consider the name equals Kyle conditions in place of the friend id equals Kyle conditions .",
    "predicted_parse_explanation": [
      "find the number of rows in friend table whose friend id equals Kyle"
    ],
    "primary_span": [
      [
        0,
        8
      ],
      [
        14,
        19
      ]
    ],
    "secondary_span": [
      [
        9,
        13
      ],
      [
        20,
        29
      ]
    ],
    "edits": [
      "high schooler",
      "name equals \"Kyle\"",
      "friend id equals \"Kyle\""
    ],
    "edits_original": "< from > add high schooler </ from > < where > add name equals \" Kyle \" </ where > < where > remove friend id equals \" Kyle \" </ where >"
  },
  {
    "question": "Give the flight numbers of flights leaving from Aberdeen.",
    "db_id": "flight_2",
    "gold_parse": "SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport   =  T2.AirportCode WHERE T2.City  =  \"Aberdeen\"",
    "feedback": "Substitute destination airport with source airport",
    "predicted_parse_with_values": "select FlightNo from flights where DestAirport = \"Aberdeen\"",
    "template_feedback": "additionally use the information from the airports table besides the flights table . consider the city equals Aberdeen conditions in place of the destination airport equals Aberdeen conditions .",
    "predicted_parse_explanation": [
      "find the flight number in flights table whose destination airport equals Aberdeen"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        13,
        18
      ]
    ],
    "secondary_span": [
      [
        8,
        12
      ],
      [
        19,
        28
      ]
    ],
    "edits": [
      "airports",
      "city equals \"Aberdeen\"",
      "destination airport equals \"Aberdeen\""
    ],
    "edits_original": "< from > add airports </ from > < where > add city equals \" Aberdeen \" </ where > < where > remove destination airport equals \" Aberdeen \" </ where >"
  },
  {
    "question": "find id of the tv channels that from the countries where have more than two tv channels.",
    "db_id": "tvshow",
    "gold_parse": "SELECT id FROM tv_channel GROUP BY country HAVING count(*)  >  2",
    "feedback": "Change id with country in step 1.",
    "predicted_parse_with_values": "select id from TV_Channel group by id having count ( * ) > 2",
    "template_feedback": "in step 1 , find for value of country in place of id .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of id in tv channel table",
      "Step 2: find the id in tv channel table whose corresponding value in step 1 is greater than 2"
    ],
    "primary_span": [
      [
        4,
        8
      ]
    ],
    "secondary_span": [
      [
        9,
        13
      ]
    ],
    "edits": [
      "country",
      "id"
    ],
    "edits_original": "< groupBy > add country </ groupBy > < groupBy > remove id </ groupBy >"
  },
  {
    "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'",
    "feedback": "In step 1 also find correspondence in degree programs table; In step 2 replace degree programs with degree summary name",
    "predicted_parse_with_values": "select T1.first_name , T1.middle_name , T1.last_name from Students as T1 join Student_Enrolment as T2 on T1.student_id = T2.student_id where T2.degree_program_id = \"Bachelor\"",
    "template_feedback": "in step 1 , additionally use the information from the degree programs table . in step 2 , consider the degree summary name equals Bachelor conditions in place of the student enrolment 's degree program id equals Bachelor conditions . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "Step 1: for each row in students table , find the corresponding rows in student enrolment table",
      "Step 2: find the first name , middle name , last name of the results of step 1 whose degree program id equals Bachelor"
    ],
    "primary_span": [
      [
        4,
        13
      ],
      [
        18,
        25
      ],
      [
        40,
        47
      ]
    ],
    "secondary_span": [
      [
        26,
        39
      ]
    ],
    "edits": [
      "distinct",
      "degree programs",
      "degree summary name equals \"Bachelor\"",
      "degree program id equals \"Bachelor\""
    ],
    "edits_original": "< select > add distinct </ select > < from > add degree programs </ from > < where > add degree summary name equals \" Bachelor \" </ where > < where > remove degree program id equals \" Bachelor \" </ where >"
  },
  {
    "question": "How many friends does the high school student Kyle have?",
    "db_id": "network_1",
    "gold_parse": "SELECT count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  \"Kyle\"",
    "feedback": "Find number of rows of student id in friend table whose corresponding high schooler 's name equals Kyle.",
    "predicted_parse_with_values": "select count ( * ) from Highschooler where name = \"Kyle\"",
    "template_feedback": "additionally use the information from the friend table besides the high schooler table .",
    "predicted_parse_explanation": [
      "find the number of rows in high schooler table whose name equals Kyle"
    ],
    "primary_span": [
      [
        0,
        7
      ]
    ],
    "secondary_span": [
      [
        8,
        13
      ]
    ],
    "edits": [
      "friend"
    ],
    "edits_original": "< from > add friend </ from >"
  },
  {
    "question": "Find all airlines that have flights from both airports 'APG' and 'CVO'.",
    "db_id": "flight_2",
    "gold_parse": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\" INTERSECT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\"",
    "feedback": "In step 1 and 2 , Change  destination airport with  source airport",
    "predicted_parse_with_values": "select Airline from flights where DestAirport = \"APG\" intersect select Airline from flights where DestAirport = \"CVO\"",
    "template_feedback": "in step 1 , additionally use the information from the airlines table besides the flights table . consider the source airport equals APG conditions in place of the destination airport equals APG conditions . find airlines 's airline name in place of flights 's airline . in step 2 , additionally use the information from the airlines table besides the flights table . consider the source airport equals CVO conditions in place of the destination airport equals CVO conditions . find airlines 's airline name in place of flights 's airline .",
    "predicted_parse_explanation": [
      "Step 1: find the airline in flights table whose destination airport equals APG",
      "Step 2: find the airline in flights table whose destination airport equals CVO",
      "Step 3: show the rows that are in both the results of step 1 and step 2"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        17,
        23
      ],
      [
        34,
        38
      ],
      [
        50,
        57
      ],
      [
        63,
        69
      ],
      [
        80,
        84
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ],
      [
        24,
        33
      ],
      [
        39,
        45
      ],
      [
        58,
        62
      ],
      [
        70,
        79
      ],
      [
        85,
        91
      ]
    ],
    "edits": [
      "airline name",
      "airline",
      "airlines",
      "source airport equals \"APG\"",
      "destination airport equals \"APG\"",
      "airline name",
      "airline",
      "airlines",
      "source airport equals \"CVO\"",
      "destination airport equals \"CVO\""
    ],
    "edits_original": "< select > add airline name </ select > < select > remove airline </ select > < from > add airlines </ from > < where > add source airport equals \" APG \" </ where > < where > remove destination airport equals \" APG \" </ where > < select > add airline name </ select > < select > remove airline </ select > < from > add airlines </ from > < where > add source airport equals \" CVO \" </ where > < where > remove destination airport equals \" CVO \" </ where >"
  },
  {
    "question": "What is the TV Channel of TV series with Episode \"A Love of a Lifetime\"? List the TV Channel's series name.",
    "db_id": "tvshow",
    "gold_parse": "SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = \"A Love of a Lifetime\"",
    "feedback": "Also find corresponding tv channel 's series name",
    "predicted_parse_with_values": "select Channel from TV_series where Episode = \"A Love of a Lifetime\"",
    "template_feedback": "additionally use the information from the tv channel table besides the tv series table . find series name in place of channel .",
    "predicted_parse_explanation": [
      "find the channel in tv series table whose episode equals A Love of a Lifetime"
    ],
    "primary_span": [
      [
        0,
        8
      ],
      [
        15,
        17
      ]
    ],
    "secondary_span": [
      [
        9,
        14
      ],
      [
        18,
        22
      ]
    ],
    "edits": [
      "series name",
      "channel",
      "tv channel"
    ],
    "edits_original": "< select > add series name </ select > < select > remove channel </ select > < from > add tv channel </ from >"
  },
  {
    "question": "What are the country codes of the different countries, and what are the languages spoken by the greatest percentage of people for each?",
    "db_id": "world_1",
    "gold_parse": "SELECT LANGUAGE ,  CountryCode ,  max(Percentage) FROM countrylanguage GROUP BY CountryCode",
    "feedback": "Find country 's code along with corresponding countrylanguage 's language whose value of percentage is highest.",
    "predicted_parse_with_values": "select T1.Code , sum ( T2.Percentage ) from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode group by T1.Code order by sum ( T1.Population ) desc limit 1",
    "template_feedback": "in step 1 , do not use the country table . in step 3 , additionally find language . find maximum percentage in place of summation of percentage . you should not find the largest of the results . show me all the results .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the summation of population of each value of code of the results of step 1",
      "Step 3: find the code and summation of percentage of the results of step 1 with largest value in the results of step 2"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        18
      ],
      [
        19,
        21
      ],
      [
        29,
        44
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        22,
        28
      ]
    ],
    "edits": [
      "language",
      "countrycode",
      "maximum percentage",
      "code",
      "summation of percentage",
      "country",
      "countrycode",
      "code",
      "summation of population",
      "descending",
      "1"
    ],
    "edits_original": "< select > add language </ select > < select > add countrycode </ select > < select > add maximum percentage </ select > < select > remove code </ select > < select > remove summation of percentage </ select > < from > remove country </ from > < groupBy > add countrycode </ groupBy > < groupBy > remove code </ groupBy > < orderBy > remove summation of population </ orderBy > < orderBy > remove descending </ orderBy > < limit > remove 1 </ limit >"
  },
  {
    "question": "What is the number of the cars with horsepower more than 150?",
    "db_id": "car_1",
    "gold_parse": "SELECT count(*) FROM CARS_DATA WHERE horsepower  >  150",
    "feedback": "only use cars data , remove step 1",
    "predicted_parse_with_values": "select count ( * ) from cars_data as T1 join car_names as T2 on T1.Id = T2.MakeId where T1.Horsepower > 150",
    "template_feedback": "in step 1 , do not use the car names table .",
    "predicted_parse_explanation": [
      "Step 1: for each row in cars data table , find the corresponding rows in car names table",
      "Step 2: find the number of rows of the results of step 1 whose horsepower greater than 150"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        4,
        11
      ]
    ],
    "edits": [
      "car names"
    ],
    "edits_original": "< from > remove car names </ from >"
  },
  {
    "question": "How many official languages does Afghanistan have?",
    "db_id": "world_1",
    "gold_parse": "SELECT COUNT(*) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Afghanistan\" AND IsOfficial  =  \"T\"",
    "feedback": "Also make sure is official equals T in step 2.",
    "predicted_parse_with_values": "select count ( T2.Language ) from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T1.Name = \"Afghanistan\"",
    "template_feedback": "in step 2 , additionally make sure that is official equals T . find number of rows in place of number of language .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the number of language of the results of step 1 whose name equals Afghanistan"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        12,
        15
      ]
    ],
    "secondary_span": [
      [
        16,
        22
      ]
    ],
    "edits": [
      "number of rows",
      "number of language",
      "is official equals \"T\""
    ],
    "edits_original": "< select > add number of rows </ select > < select > remove number of language </ select > < where > add is official equals \" T \" </ where >"
  },
  {
    "question": "What is the number of car models created by the car maker American Motor Company?",
    "db_id": "car_1",
    "gold_parse": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker WHERE T1.FullName  =  'American Motor Company'",
    "feedback": "Find count of model list 's maker whose corresponding car makers 's maker equals American Motor Company.",
    "predicted_parse_with_values": "select count ( * ) from car_makers where Maker = \"American Motor Company\"",
    "template_feedback": "additionally use the information from the model list table besides the car makers table . consider the full name equals American Motor Company conditions in place of the car makers 's maker equals American Motor Company conditions .",
    "predicted_parse_explanation": [
      "find the number of rows in car makers table whose maker equals American Motor Company"
    ],
    "primary_span": [
      [
        0,
        8
      ],
      [
        15,
        23
      ]
    ],
    "secondary_span": [
      [
        9,
        14
      ],
      [
        24,
        37
      ]
    ],
    "edits": [
      "model list",
      "full name equals \"American Motor Company\"",
      "maker equals \"American Motor Company\""
    ],
    "edits_original": "< from > add model list </ from > < where > add full name equals \" American Motor Company \" </ where > < where > remove maker equals \" American Motor Company \" </ where >"
  },
  {
    "question": "Which owner owns the most dogs? List the owner id, first name and last name.",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT T1.owner_id ,  T2.first_name ,  T2.last_name FROM Dogs AS T1 JOIN Owners AS T2 ON T1.owner_id  =  T2.owner_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",
    "feedback": "In step 1 , Swap owners table\" with dogs table\".",
    "predicted_parse_with_values": "select owner_id , first_name , last_name from Owners group by owner_id order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the dogs table besides the owners table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of owner id in owners table",
      "Step 2: find the owner id , first name , last name in owners table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "dogs"
    ],
    "edits_original": "< from > add dogs </ from >"
  },
  {
    "question": "What are the names of the teachers and how many courses do they teach?",
    "db_id": "course_teach",
    "gold_parse": "SELECT T2.Name ,  COUNT(*) FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name",
    "feedback": "Ensure to find number of corresponding rows to each value of teacher id in course arrange table.",
    "predicted_parse_with_values": "select Name , count ( * ) from teacher group by Name",
    "template_feedback": "additionally use the information from the course arrange table besides the teacher table .",
    "predicted_parse_explanation": [
      "find each value of name in teacher table along with the number of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        0,
        8
      ]
    ],
    "secondary_span": [
      [
        9,
        13
      ]
    ],
    "edits": [
      "course arrange"
    ],
    "edits_original": "< from > add course arrange </ from >"
  },
  {
    "question": "Give the average life expectancy for countries in Africa which are republics?",
    "db_id": "world_1",
    "gold_parse": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  \"Africa\" AND GovernmentForm  =  \"Republic\"",
    "feedback": "Make certain that the government form equals Republic.",
    "predicted_parse_with_values": "select avg ( LifeExpectancy ) from country where Continent =  \"Africa\"",
    "template_feedback": "additionally make sure that government form equals Republic .",
    "predicted_parse_explanation": [
      "find the average life expectancy in country table whose continent equals Africa"
    ],
    "primary_span": [
      [
        0,
        8
      ]
    ],
    "secondary_span": [],
    "edits": [
      "government form equals \"Republic\""
    ],
    "edits_original": "< where > add government form equals \" Republic \" </ where >"
  },
  {
    "question": "Which city has the most frequent destination airport?",
    "db_id": "flight_2",
    "gold_parse": "SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1",
    "feedback": "Substitute city in airports table with destination airport in flights table in step 1.",
    "predicted_parse_with_values": "select City from airports group by City order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the flights table besides the airports table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of city in airports table",
      "Step 2: find the city in airports table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ]
    ],
    "edits": [
      "flights"
    ],
    "edits_original": "< from > add flights </ from >"
  },
  {
    "question": "How many total tours were there for each ranking date?",
    "db_id": "wta_1",
    "gold_parse": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date",
    "feedback": "Replace rankings with tours",
    "predicted_parse_with_values": "select sum ( ranking ) , ranking_date from rankings group by ranking_date",
    "template_feedback": "find summation of tours in place of summation of ranking .",
    "predicted_parse_explanation": [
      "find each value of ranking date in rankings table along with the summation of ranking of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        0,
        3
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ]
    ],
    "edits": [
      "summation of tours",
      "summation of ranking"
    ],
    "edits_original": "< select > add summation of tours </ select > < select > remove summation of ranking </ select >"
  },
  {
    "question": "Show the years in which orchestras that have given more than one performance are founded.",
    "db_id": "orchestra",
    "gold_parse": "SELECT Year_of_Founded FROM orchestra AS T1 JOIN performance AS T2 ON T1.Orchestra_ID  =  T2.Orchestra_ID GROUP BY T2.Orchestra_ID HAVING COUNT(*)  >  1",
    "feedback": "Supersede orchestra in orchestra table\" with orchestra id in performance table in step 1.",
    "predicted_parse_with_values": "select Year_of_Founded from orchestra group by Orchestra having count ( * ) > 1",
    "template_feedback": "in step 1 , additionally use the information from the performance table besides the orchestra table . find for value of performance 's orchestra id in place of orchestra .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of orchestra in orchestra table",
      "Step 2: find the year of founded in orchestra table whose corresponding value in step 1 is greater than 1"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        17,
        24
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ],
      [
        25,
        29
      ]
    ],
    "edits": [
      "performance",
      "orchestra id",
      "orchestra"
    ],
    "edits_original": "< from > add performance </ from > < groupBy > add orchestra id </ groupBy > < groupBy > remove orchestra </ groupBy >"
  },
  {
    "question": "What is the last name of the student who has a cat that is 3 years old?",
    "db_id": "pets_1",
    "gold_parse": "SELECT T1.lname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pet_age  =  3 AND T3.pettype  =  'cat'",
    "feedback": "Substitute \"Age\" with \"Corresponding pet age from pets table\" and verify that pet type equals cat.",
    "predicted_parse_with_values": "select LName from Student where Age = 3",
    "template_feedback": "additionally use the information from the pets table and has pet table besides the student table . consider the pet age equals 3 and pet type equals cat conditions in place of the age equals 3 conditions .",
    "predicted_parse_explanation": [
      "find the last name in student table whose age equals 3"
    ],
    "primary_span": [
      [
        0,
        11
      ],
      [
        17,
        28
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ],
      [
        29,
        37
      ]
    ],
    "edits": [
      "has pet",
      "pets",
      "pet age equals 3",
      "pet type equals \"cat\"",
      "age equals 3"
    ],
    "edits_original": "< from > add has pet </ from > < from > add pets </ from > < where > add pet age equals 3 </ where > < where > add pet type equals \" cat \" </ where > < where > remove age equals 3 </ where >"
  },
  {
    "question": "Which of the countries has the most car makers? List the country name.",
    "db_id": "car_1",
    "gold_parse": "SELECT T2.CountryName FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId GROUP BY T1.Country ORDER BY Count(*) DESC LIMIT 1",
    "feedback": "In step 2 swap country id of car makers table with country name of countries table.",
    "predicted_parse_with_values": "select Country from car_makers group by Country order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the countries table besides the car makers table . in step 2 , find country name in place of country .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of country in car makers table",
      "Step 2: find the country in car makers table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        22,
        24
      ]
    ],
    "secondary_span": [
      [
        12,
        17
      ],
      [
        25,
        29
      ]
    ],
    "edits": [
      "country name",
      "country",
      "countries"
    ],
    "edits_original": "< select > add country name </ select > < select > remove country </ select > < from > add countries </ from >"
  },
  {
    "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",
    "feedback": "Also find correspondence in treatments table in step 1; Swap dogs 's owner id with treatments 's dog id(step 2).",
    "predicted_parse_with_values": "select T2.owner_id , T1.last_name from Owners as T1 join Dogs as T2 on T1.owner_id = T2.owner_id group by T2.owner_id order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the treatments table .",
    "predicted_parse_explanation": [
      "Step 1: for each row in owners table , find the corresponding rows in dogs table",
      "Step 2: find the number of rows of each value of dogs 's owner id of the results of step 1",
      "Step 3: find the dogs 's owner id and last name of the results of step 1 with largest value in the results of step 2"
    ],
    "primary_span": [
      [
        4,
        12
      ]
    ],
    "secondary_span": [],
    "edits": [
      "treatments"
    ],
    "edits_original": "< from > add treatments </ from >"
  },
  {
    "question": "Find the first name and age of students who have a pet.",
    "db_id": "pets_1",
    "gold_parse": "SELECT DISTINCT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid",
    "feedback": "Making sure that his or her student id is not present in has pet table 's student id",
    "predicted_parse_with_values": "select Fname , Age from Student",
    "template_feedback": "additionally use the information from the has pet table besides the student table . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "find the first name and age in student table"
    ],
    "primary_span": [
      [
        0,
        8
      ],
      [
        14,
        21
      ]
    ],
    "secondary_span": [
      [
        9,
        13
      ]
    ],
    "edits": [
      "distinct",
      "has pet"
    ],
    "edits_original": "< select > add distinct </ select > < from > add has pet </ from >"
  },
  {
    "question": "What is the best rank of losers across all matches?",
    "db_id": "wta_1",
    "gold_parse": "SELECT min(loser_rank) FROM matches",
    "feedback": "Supersede loser rank points with loser rank",
    "predicted_parse_with_values": "select max ( loser_rank_points ) from matches",
    "template_feedback": "find minimum loser rank in place of maximum loser rank points .",
    "predicted_parse_explanation": [
      "find the maximum loser rank points in matches table"
    ],
    "primary_span": [
      [
        0,
        3
      ]
    ],
    "secondary_span": [
      [
        4,
        11
      ]
    ],
    "edits": [
      "minimum loser rank",
      "maximum loser rank points"
    ],
    "edits_original": "< select > add minimum loser rank </ select > < select > remove maximum loser rank points </ select >"
  },
  {
    "question": "Tell me the age of the oldest dog.",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT max(age) FROM Dogs",
    "feedback": "Exchange date adopted with \"age\".",
    "predicted_parse_with_values": "select age from Dogs order by date_adopted desc limit 1",
    "template_feedback": "find maximum age in place of age . you should not find the largest of the results . show me all the results .",
    "predicted_parse_explanation": [
      "find the age in dogs table with largest value of date adopted"
    ],
    "primary_span": [
      [
        0,
        2
      ],
      [
        8,
        23
      ]
    ],
    "secondary_span": [
      [
        3,
        7
      ]
    ],
    "edits": [
      "maximum age",
      "age",
      "date adopted",
      "descending",
      "1"
    ],
    "edits_original": "< select > add maximum age </ select > < select > remove age </ select > < orderBy > remove date adopted </ orderBy > < orderBy > remove descending </ orderBy > < limit > remove 1 </ limit >"
  },
  {
    "question": "Which owners live in the state whose name contains the substring 'North'? List his first name, last name and email.",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT first_name ,  last_name ,  email_address FROM Owners WHERE state LIKE '%North%'",
    "feedback": "Do find \"email\" ahead of last name",
    "predicted_parse_with_values": "select first_name , last_name from Owners where state like \"%North%\"",
    "template_feedback": "additionally find email address .",
    "predicted_parse_explanation": [
      "find the first name and last name in owners table whose state like % North %"
    ],
    "primary_span": [
      [
        0,
        4
      ]
    ],
    "secondary_span": [],
    "edits": [
      "email address"
    ],
    "edits_original": "< select > add email address </ select >"
  },
  {
    "question": "Show the property type descriptions of properties belonging to that code.",
    "db_id": "real_estate_properties",
    "gold_parse": "SELECT T2.property_type_description FROM Properties AS T1 JOIN Ref_Property_Types AS T2 ON T1.property_type_code  =  T2.property_type_code GROUP BY T1.property_type_code",
    "feedback": "Ascertain to find property type code as well.",
    "predicted_parse_with_values": "select property_type_description from Ref_Property_Types",
    "template_feedback": "additionally use the information from the properties table besides the reference property types table . find for each value of properties 's property type code .",
    "predicted_parse_explanation": [
      "find the property type description in reference property types table"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        15,
        25
      ]
    ],
    "secondary_span": [
      [
        8,
        14
      ]
    ],
    "edits": [
      "properties",
      "property type code"
    ],
    "edits_original": "< from > add properties </ from > < groupBy > add property type code </ groupBy >"
  },
  {
    "question": "What is the average and maximum capacities for all stations?",
    "db_id": "concert_singer",
    "gold_parse": "SELECT avg(capacity) ,  max(capacity) FROM stadium",
    "feedback": "Given table is not sufficient to answer question.",
    "predicted_parse_with_values": "select avg ( Average ) , max ( Capacity ) from stadium",
    "template_feedback": "find average capacity in place of average average .",
    "predicted_parse_explanation": [
      "find the average average and maximum capacity in stadium table"
    ],
    "primary_span": [
      [
        0,
        2
      ]
    ],
    "secondary_span": [
      [
        3,
        8
      ]
    ],
    "edits": [
      "average capacity",
      "average average"
    ],
    "edits_original": "< select > add average capacity </ select > < select > remove average average </ select >"
  },
  {
    "question": "What are the first names of all players, and their total ranking points?",
    "db_id": "wta_1",
    "gold_parse": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",
    "feedback": "In step 2 , Exchange player id with first name",
    "predicted_parse_with_values": "select T1.first_name , sum ( T2.ranking_points ) from players as T1 join rankings as T2 on T1.player_id = T2.player_id group by T2.player_id",
    "template_feedback": "in step 2 , find for each value of first name in place of rankings 's player id .",
    "predicted_parse_explanation": [
      "Step 1: for each row in players table , find the corresponding rows in rankings table",
      "Step 2: find each value of rankings 's player id of the results of step 1 along with the summation of ranking points and first name of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        4,
        10
      ]
    ],
    "secondary_span": [
      [
        11,
        18
      ]
    ],
    "edits": [
      "first name",
      "player id"
    ],
    "edits_original": "< groupBy > add first name </ groupBy > < groupBy > remove player id </ groupBy >"
  },
  {
    "question": "What is maximum and minimum death toll caused each time?",
    "db_id": "battle_death",
    "gold_parse": "SELECT max(killed) ,  min(killed) FROM death",
    "feedback": "Substitute injured by killed",
    "predicted_parse_with_values": "select max ( killed ) , min ( injured ) from death",
    "template_feedback": "find minimum killed in place of minimum injured .",
    "predicted_parse_explanation": [
      "find the maximum killed and minimum injured in death table"
    ],
    "primary_span": [
      [
        0,
        2
      ]
    ],
    "secondary_span": [
      [
        3,
        8
      ]
    ],
    "edits": [
      "minimum killed",
      "minimum injured"
    ],
    "edits_original": "< select > add minimum killed </ select > < select > remove minimum injured </ select >"
  },
  {
    "question": "Where is the youngest teacher from?",
    "db_id": "course_teach",
    "gold_parse": "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1",
    "feedback": "Swap name with hometown",
    "predicted_parse_with_values": "select Name from teacher order by Age limit 1",
    "template_feedback": "find hometown in place of name .",
    "predicted_parse_explanation": [
      "find the name in teacher table with smallest value of age"
    ],
    "primary_span": [
      [
        0,
        1
      ]
    ],
    "secondary_span": [
      [
        2,
        6
      ]
    ],
    "edits": [
      "hometown",
      "name"
    ],
    "edits_original": "< select > add hometown </ select > < select > remove name </ select >"
  },
  {
    "question": "What is the minimu weight of the car with 8 cylinders produced in 1974?",
    "db_id": "car_1",
    "gold_parse": "SELECT Weight FROM CARS_DATA WHERE Cylinders  =  8 AND YEAR  =  1974 ORDER BY Weight ASC LIMIT 1",
    "feedback": "Find minimum weight , change 1 with 8 and cylinders equals 4 with year equals 1974.",
    "predicted_parse_with_values": "select Weight from cars_data where Cylinders = 1 and Cylinders = 4",
    "template_feedback": "consider the year equals 1974 and cylinders equals 8 conditions in place of the cylinders equals 4 and cylinders equals 1 conditions . find the result with the smallest weight .",
    "predicted_parse_explanation": [
      "find the weight in cars data table whose cylinders equals 1 and cylinders equals 4"
    ],
    "primary_span": [
      [
        0,
        9
      ],
      [
        23,
        30
      ]
    ],
    "secondary_span": [
      [
        10,
        22
      ]
    ],
    "edits": [
      "cylinders equals 8",
      "year equals 1974",
      "cylinders equals 1",
      "cylinders equals 4",
      "weight",
      "1"
    ],
    "edits_original": "< where > add cylinders equals 8 </ where > < where > add year equals 1974 </ where > < where > remove cylinders equals 1 </ where > < where > remove cylinders equals 4 </ where > < orderBy > add weight </ orderBy > < limit > add 1 </ limit >"
  },
  {
    "question": "What are the names of nations where both English and French are official languages?",
    "db_id": "world_1",
    "gold_parse": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\" AND T2.IsOfficial  =  \"T\"",
    "feedback": "Also ensure language equals English(step 2); Replace government form with language and also ensure is official equals T(step 3)",
    "predicted_parse_with_values": "select T1.Name from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T2.IsOfficial = \"T\" intersect select Name from country where GovernmentForm = \"English\"",
    "template_feedback": "in step 2 , additionally make sure that language equals English . in step 3 , additionally use the information from the countrylanguage table besides the country table . consider the is official equals T and language equals French conditions in place of the government form equals English conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the name of the results of step 1 whose is official equals T",
      "Step 3: find the name in country table whose government form equals English",
      "Step 4: show the rows that are in both the results of step 2 and step 3"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        16,
        23
      ],
      [
        29,
        39
      ]
    ],
    "secondary_span": [
      [
        24,
        28
      ],
      [
        40,
        49
      ]
    ],
    "edits": [
      "language equals \"English\"",
      "countrylanguage",
      "language equals \"French\"",
      "is official equals \"T\"",
      "government form equals \"English\""
    ],
    "edits_original": "< where > add language equals \" English \" </ where > < from > add countrylanguage </ from > < where > add language equals \" French \" </ where > < where > add is official equals \" T \" </ where > < where > remove government form equals \" English \" </ where >"
  },
  {
    "question": "How many different degrees are offered?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT count(DISTINCT degree_summary_name) FROM Degree_Programs",
    "feedback": "it should be the number of unique degree summary name",
    "predicted_parse_with_values": "select count ( * ) from Degree_Programs",
    "template_feedback": "find number of different degree summary name in place of number of rows .",
    "predicted_parse_explanation": [
      "find the number of rows in degree programs table"
    ],
    "primary_span": [
      [
        0,
        6
      ]
    ],
    "secondary_span": [
      [
        7,
        13
      ]
    ],
    "edits": [
      "number of distinct degree summary name",
      "number of rows"
    ],
    "edits_original": "< select > add number of distinct degree summary name </ select > < select > remove number of rows </ select >"
  },
  {
    "question": "What are the first names and country codes for players who won both the WTA Championships and the Australian Open?",
    "db_id": "wta_1",
    "gold_parse": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'WTA Championships' INTERSECT SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'Australian Open'",
    "feedback": "Ensure whose player id is in winner id hand tourney name equals \"WTA Championships\" and \"Australian Open\" both.",
    "predicted_parse_with_values": "select first_name , country_code from players where player_id = 1 intersect select T2.first_name , T2.country_code from matches as T1 join players as T2 on T1.winner_id = T2.player_id where T1.winner_name = \"WTA Championships\"",
    "template_feedback": "in step 1 , additionally use the information from the matches table besides the players table . consider the tourney name equals WTA Championships conditions in place of the player id equals 1 conditions . in step 3 , consider the tourney name equals Australian Open conditions in place of the winner name equals WTA Championships conditions .",
    "predicted_parse_explanation": [
      "Step 1: find the first name and country code in players table whose player id equals 1",
      "Step 2: for each row in matches table , find the corresponding rows in players table",
      "Step 3: find the first name and country code of the results of step 2 whose winner name equals WTA Championships",
      "Step 4: show the rows that are in both the results of step 1 and step 3"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        17,
        24
      ],
      [
        39,
        46
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ],
      [
        25,
        34
      ],
      [
        47,
        57
      ]
    ],
    "edits": [
      "matches",
      "tourney name equals \"WTA Championships\"",
      "player id equals 1",
      "tourney name equals \"Australian Open\"",
      "winner name equals \"WTA Championships\""
    ],
    "edits_original": "< from > add matches </ from > < where > add tourney name equals \" WTA Championships \" </ where > < where > remove player id equals 1 </ where > < where > add tourney name equals \" Australian Open \" </ where > < where > remove winner name equals \" WTA Championships \" </ where >"
  },
  {
    "question": "Who is the earliest graduate of the school? List the first name, middle name and last name.",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_left ASC LIMIT 1",
    "feedback": "Change date first registered with date left",
    "predicted_parse_with_values": "select first_name , middle_name , last_name from Students order by date_first_registered asc limit 1",
    "template_feedback": "order the results by date left in place of date first registered .",
    "predicted_parse_explanation": [
      "find the first name , middle name , last name in students table with smallest value of date first registered"
    ],
    "primary_span": [
      [
        0,
        5
      ]
    ],
    "secondary_span": [
      [
        6,
        12
      ]
    ],
    "edits": [
      "date left",
      "date first registered"
    ],
    "edits_original": "< orderBy > add date left </ orderBy > < orderBy > remove date first registered </ orderBy >"
  },
  {
    "question": "How many people live in Gelderland district?",
    "db_id": "world_1",
    "gold_parse": "SELECT sum(Population) FROM city WHERE District  =  \"Gelderland\"",
    "feedback": "In step 2 , Exchange  country population ' with  city population '.",
    "predicted_parse_with_values": "select T1.Population from country as T1 join city as T2 on T1.Code = T2.CountryCode where T2.District = \"Gelderland\"",
    "template_feedback": "in step 1 , do not use the country table . in step 2 , find summation of city 's population in place of country 's population .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in city table",
      "Step 2: find the country 's population of the results of step 1 whose district equals Gelderland"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        20
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        21,
        27
      ]
    ],
    "edits": [
      "summation of population",
      "population",
      "country"
    ],
    "edits_original": "< select > add summation of population </ select > < select > remove population </ select > < from > remove country </ from >"
  },
  {
    "question": "What are the different models created by either the car maker General Motors or weighed more than 3500?",
    "db_id": "car_1",
    "gold_parse": "SELECT DISTINCT T2.Model FROM CAR_NAMES AS T1 JOIN MODEL_LIST AS T2 ON T1.Model  =  T2.Model JOIN CAR_MAKERS AS T3 ON T2.Maker  =  T3.Id JOIN CARS_DATA AS T4 ON T1.MakeId  =  T4.Id WHERE T3.FullName  =  'General Motors' OR T4.weight  >  3500",
    "feedback": "Step 1 , Swap car names with cars data Step 2 , Swap second car makers 's maker with cars data 's weight , Ensure Uniqueness.",
    "predicted_parse_with_values": "select T3.Model from car_makers as T1 join model_list as T2 on T1.Id = T2.Maker join car_names as T3 on T2.Model = T3.Model where T1.Maker = \"General Motors\" or T1.Maker = 3500",
    "template_feedback": "in step 1 , additionally use the information from the cars data table . in step 2 , consider the weight greater than 3500 or full name equals General Motors conditions in place of the car makers 's maker equals 3500 or car makers 's maker equals General Motors conditions . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "Step 1: for each row in car makers table , find the corresponding rows in model list table and in car names table",
      "Step 2: find the car names 's model of the results of step 1 whose car makers 's maker equals General Motors or car makers 's maker equals 3500"
    ],
    "primary_span": [
      [
        4,
        13
      ],
      [
        18,
        30
      ],
      [
        51,
        58
      ]
    ],
    "secondary_span": [
      [
        31,
        50
      ]
    ],
    "edits": [
      "distinct",
      "cars data",
      "full name equals \"General Motors\" or weight greater than 3500",
      "maker equals \"General Motors\" or maker equals 3500"
    ],
    "edits_original": "< select > add distinct </ select > < from > add cars data </ from > < where > add full name equals \" General Motors \" or weight greater than 3500 </ where > < where > remove maker equals \" General Motors \" or maker equals 3500 </ where >"
  },
  {
    "question": "What is the first name and country code of the player with the most tours?",
    "db_id": "wta_1",
    "gold_parse": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT 1",
    "feedback": "Interchange country code in players table with tours in rankings table in step 1.",
    "predicted_parse_with_values": "select first_name , country_code from players group by country_code order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , additionally use the information from the rankings table besides the players table . do not find for each value of country code . in step 2 , order the results by tours in place of number of rows .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of country code in players table",
      "Step 2: find the first name and country code in players table with largest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        17,
        26
      ],
      [
        31,
        35
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ],
      [
        36,
        42
      ]
    ],
    "edits": [
      "rankings",
      "country code",
      "tours",
      "number of rows"
    ],
    "edits_original": "< from > add rankings </ from > < groupBy > remove country code </ groupBy > < orderBy > add tours </ orderBy > < orderBy > remove number of rows </ orderBy >"
  },
  {
    "question": "Show ids of all students who do not have any friends.",
    "db_id": "network_1",
    "gold_parse": "SELECT id FROM Highschooler EXCEPT SELECT student_id FROM Friend",
    "feedback": "In step 1 , Change student id of friend table\" with \"ID of high schooler table\".",
    "predicted_parse_with_values": "select student_id from Friend except select student_id from Friend",
    "template_feedback": "in step 1 , use high schooler table in place of friend table .",
    "predicted_parse_explanation": [
      "Step 1: find the student id in friend table",
      "Step 2: find the student id in friend table",
      "Step 3: show the rows that are in the results of step 1 but not in the results of step 2"
    ],
    "primary_span": [
      [
        4,
        7
      ]
    ],
    "secondary_span": [
      [
        8,
        13
      ]
    ],
    "edits": [
      "id",
      "student id",
      "high schooler",
      "friend"
    ],
    "edits_original": "< select > add id </ select > < select > remove student id </ select > < from > add high schooler </ from > < from > remove friend </ from >"
  },
  {
    "question": "What is the language that is used by the largest number of Asian nations?",
    "db_id": "world_1",
    "gold_parse": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Continent  =  \"Asia\" GROUP BY T2.Language ORDER BY COUNT (*) DESC LIMIT 1",
    "feedback": "Change population with percentage in step 2.",
    "predicted_parse_with_values": "select T2.Language from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T1.Continent = \"Asia\" order by T1.Population desc limit 1",
    "template_feedback": "in step 2 , find for each value of language . order the results by number of rows in place of population .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the language of the results of step 1 whose continent equals Asia with largest value of population"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        11,
        17
      ]
    ],
    "secondary_span": [
      [
        18,
        22
      ]
    ],
    "edits": [
      "language",
      "number of rows",
      "population"
    ],
    "edits_original": "< groupBy > add language </ groupBy > < orderBy > add number of rows </ orderBy > < orderBy > remove population </ orderBy >"
  },
  {
    "question": "Find the abbreviation and country of the airline that has fewest number of flights?",
    "db_id": "flight_2",
    "gold_parse": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1",
    "feedback": "Swap airline id in airlines table\" with airlines in flights table\" in step 1",
    "predicted_parse_with_values": "select Abbreviation , Country from airlines group by uid order by count ( * ) limit 1",
    "template_feedback": "in step 1 , additionally use the information from the flights table besides the airlines table . find for each value of airlines 's airline name in place of airline id .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of airline id in airlines table",
      "Step 2: find the abbreviation and country in airlines table with smallest value in the results of step 1"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        17,
        25
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ],
      [
        26,
        31
      ]
    ],
    "edits": [
      "flights",
      "airline name",
      "airline id"
    ],
    "edits_original": "< from > add flights </ from > < groupBy > add airline name </ groupBy > < groupBy > remove airline id </ groupBy >"
  },
  {
    "question": "Show the names of all of the high schooler Kyle's friends.",
    "db_id": "network_1",
    "gold_parse": "SELECT T3.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id JOIN Highschooler AS T3 ON T1.friend_id  =  T3.id WHERE T2.name  =  \"Kyle\"",
    "feedback": "Find all friend id and corresponding name for student id which corresponds to high schooler 's name Kyle.",
    "predicted_parse_with_values": "select name from Highschooler where grade = 5",
    "template_feedback": "additionally use the information from the friend table besides the high schooler table . consider the name equals Kyle conditions in place of the grade equals 5 conditions .",
    "predicted_parse_explanation": [
      "find the name in high schooler table whose grade equals 5"
    ],
    "primary_span": [
      [
        0,
        7
      ],
      [
        14,
        19
      ]
    ],
    "secondary_span": [
      [
        8,
        13
      ],
      [
        20,
        28
      ]
    ],
    "edits": [
      "friend",
      "high schooler",
      "name equals \"Kyle\"",
      "grade equals 5"
    ],
    "edits_original": "< from > add friend </ from > < from > add high schooler </ from > < where > add name equals \" Kyle \" </ where > < where > remove grade equals 5 </ where >"
  },
  {
    "question": "Which city and country is the Alton airport at?",
    "db_id": "flight_2",
    "gold_parse": "SELECT City ,  Country FROM AIRPORTS WHERE AirportName  =  \"Alton\"",
    "feedback": "Substitute airport code with airport name",
    "predicted_parse_with_values": "select City , Country from airports where AirportCode = \"Alton\"",
    "template_feedback": "consider the airport name equals Alton conditions in place of the airport code equals Alton conditions .",
    "predicted_parse_explanation": [
      "find the city and country in airports table whose airport code equals Alton"
    ],
    "primary_span": [
      [
        0,
        6
      ]
    ],
    "secondary_span": [
      [
        7,
        16
      ]
    ],
    "edits": [
      "airport name equals \"Alton\"",
      "airport code equals \"Alton\""
    ],
    "edits_original": "< where > add airport name equals \" Alton \" </ where > < where > remove airport code equals \" Alton \" </ where >"
  },
  {
    "question": "What are flight numbers of flights departing from Airport \"APG\"?",
    "db_id": "flight_2",
    "gold_parse": "SELECT FlightNo FROM FLIGHTS WHERE SourceAirport  =  \"APG\"",
    "feedback": "Change airport name with source airport in step 2.",
    "predicted_parse_with_values": "select T1.FlightNo from flights as T1 join airports as T2 on T1.DestAirport = T2.AirportCode where T2.AirportName = \"APG\"",
    "template_feedback": "in step 1 , do not use the airports table . in step 2 , consider the source airport equals APG conditions in place of the airport name equals APG conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in flights table , find the corresponding rows in airports table",
      "Step 2: find the flight number of the results of step 1 whose airport name equals APG"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        21
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        22,
        31
      ]
    ],
    "edits": [
      "airports",
      "source airport equals \"APG\"",
      "airport name equals \"APG\""
    ],
    "edits_original": "< from > remove airports </ from > < where > add source airport equals \" APG \" </ where > < where > remove airport name equals \" APG \" </ where >"
  },
  {
    "question": "Return the lowest version number, along with its corresponding template type code.",
    "db_id": "cre_Doc_Template_Mgt",
    "gold_parse": "SELECT min(Version_Number) ,  template_type_code FROM Templates",
    "feedback": "Substitute second template type code with version number",
    "predicted_parse_with_values": "select Version_Number , Template_Type_Code from Templates order by Template_Type_Code asc limit 1",
    "template_feedback": "find minimum version number in place of version number . you should not find the smallest of the results . show me all the results .",
    "predicted_parse_explanation": [
      "find the version number and template type code in templates table with smallest value of template type code"
    ],
    "primary_span": [
      [
        0,
        3
      ],
      [
        10,
        25
      ]
    ],
    "secondary_span": [
      [
        4,
        9
      ]
    ],
    "edits": [
      "minimum version number",
      "version number",
      "template type code",
      "1"
    ],
    "edits_original": "< select > add minimum version number </ select > < select > remove version number </ select > < orderBy > remove template type code </ orderBy > < limit > remove 1 </ limit >"
  },
  {
    "question": "How many countries have a republic as their form of government?",
    "db_id": "world_1",
    "gold_parse": "SELECT count(*) FROM country WHERE GovernmentForm  =  \"Republic\"",
    "feedback": "Change first government form with name",
    "predicted_parse_with_values": "select count ( GovernmentForm ) from country where GovernmentForm = \"Republic\"",
    "template_feedback": "find number of rows in place of number of government form .",
    "predicted_parse_explanation": [
      "find the number of government form in country table whose government form equals Republic"
    ],
    "primary_span": [
      [
        0,
        3
      ]
    ],
    "secondary_span": [
      [
        4,
        11
      ]
    ],
    "edits": [
      "number of rows",
      "number of government form"
    ],
    "edits_original": "< select > add number of rows </ select > < select > remove number of government form </ select >"
  },
  {
    "question": "When is the first transcript released? List the date and details.",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT transcript_date ,  other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1",
    "feedback": "Swap student course id with transcript id in step 2.",
    "predicted_parse_with_values": "select T2.transcript_date , T2.other_details from Transcript_Contents as T1 join Transcripts as T2 on T1.transcript_id = T2.transcript_id order by T1.student_course_id asc limit 1",
    "template_feedback": "in step 1 , do not use the transcript contents table . in step 2 , order the results by transcript date in place of student course id .",
    "predicted_parse_explanation": [
      "Step 1: for each row in transcript contents table , find the corresponding rows in transcripts table",
      "Step 2: find the transcript date and other details of the results of step 1 with smallest value of student course id"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        16,
        21
      ]
    ],
    "secondary_span": [
      [
        4,
        11
      ],
      [
        22,
        28
      ]
    ],
    "edits": [
      "transcript contents",
      "transcript date",
      "student course id"
    ],
    "edits_original": "< from > remove transcript contents </ from > < orderBy > add transcript date </ orderBy > < orderBy > remove student course id </ orderBy >"
  },
  {
    "question": "How many different degree names are offered?",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT count(DISTINCT degree_summary_name) FROM Degree_Programs",
    "feedback": "Find number of rows of distinct degree summary name in degree programs",
    "predicted_parse_with_values": "select count ( * ) from Degree_Programs",
    "template_feedback": "find number of different degree summary name in place of number of rows .",
    "predicted_parse_explanation": [
      "find the number of rows in degree programs table"
    ],
    "primary_span": [
      [
        0,
        6
      ]
    ],
    "secondary_span": [
      [
        7,
        13
      ]
    ],
    "edits": [
      "number of distinct degree summary name",
      "number of rows"
    ],
    "edits_original": "< select > add number of distinct degree summary name </ select > < select > remove number of rows </ select >"
  },
  {
    "question": "Count the number of flights into ATO.",
    "db_id": "flight_2",
    "gold_parse": "SELECT count(*) FROM FLIGHTS WHERE DestAirport  =  \"ATO\"",
    "feedback": "Change airport name with airport code in step 2.",
    "predicted_parse_with_values": "select count ( * ) from flights as T1 join airports as T2 on T1.DestAirport = T2.AirportCode where T2.AirportName = \"ATO\"",
    "template_feedback": "in step 1 , do not use the airports table . in step 2 , consider the destination airport equals ATO conditions in place of the airport name equals ATO conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in flights table , find the corresponding rows in airports table",
      "Step 2: find the number of rows of the results of step 1 whose airport name equals ATO"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        21
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        22,
        31
      ]
    ],
    "edits": [
      "airports",
      "destination airport equals \"ATO\"",
      "airport name equals \"ATO\""
    ],
    "edits_original": "< from > remove airports </ from > < where > add destination airport equals \" ATO \" </ where > < where > remove airport name equals \" ATO \" </ where >"
  },
  {
    "question": "For each continent, list its id, name, and how many countries it has?",
    "db_id": "car_1",
    "gold_parse": "SELECT T1.ContId ,  T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.Continent GROUP BY T1.ContId",
    "feedback": "In step 2 , Supersede  country name with  cont id",
    "predicted_parse_with_values": "select T1.Continent , T2.CountryName , count ( * ) from continents as T1 join countries as T2 on T1.ContId = T2.Continent group by T1.Continent",
    "template_feedback": "in step 2 , find for each value of cont id in place of continents 's continent . find cont id in place of country name .",
    "predicted_parse_explanation": [
      "Step 1: for each row in continents table , find the corresponding rows in countries table",
      "Step 2: find each value of continents 's continent of the results of step 1 along with the number of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        18,
        20
      ]
    ],
    "secondary_span": [
      [
        11,
        17
      ],
      [
        21,
        26
      ]
    ],
    "edits": [
      "cont id",
      "country name",
      "cont id",
      "continent"
    ],
    "edits_original": "< select > add cont id </ select > < select > remove country name </ select > < groupBy > add cont id </ groupBy > < groupBy > remove continent </ groupBy >"
  },
  {
    "question": "Find the average grade of all students who have some friends.",
    "db_id": "network_1",
    "gold_parse": "SELECT avg(grade) FROM Highschooler WHERE id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)",
    "feedback": "In Step 2 , Replace the second \"grade\" with \"ID\".",
    "predicted_parse_with_values": "select avg ( grade ) from Highschooler where grade in ( select student_id from Friend )",
    "template_feedback": "in step 1 , additionally use the information from the high schooler table besides the friend table . in step 2 , make sure the id is one of the results of step 1 the grade is one of the results of step 1 .",
    "predicted_parse_explanation": [
      "Step 1: find the student id in friend table",
      "Step 2: find the average grade in high schooler table whose grade one of the results of step 1"
    ],
    "primary_span": [
      [
        4,
        12
      ],
      [
        22,
        33
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ],
      [
        34,
        44
      ]
    ],
    "edits": [
      "id one of SUBS1",
      "grade one of SUBS1",
      "high schooler"
    ],
    "edits_original": "< where > add id one of SUBS1 </ where > < where > remove grade one of SUBS1 </ where > < from > add high schooler </ from >"
  },
  {
    "question": "Find the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.",
    "db_id": "student_transcripts_tracking",
    "gold_parse": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id",
    "feedback": "Ensure corresponding current address id 's state province county equals NorthCarolina(step 2); Ensure corresponding student id present in student enrolment table(step 3).",
    "predicted_parse_with_values": "select T1.last_name from Students as T1 join Addresses as T2 on T1.permanent_address_id = T2.address_id where T2.state_province_county = \"NorthCarolina\" except select last_name from Students",
    "template_feedback": "in step 3 , additionally use the information from the student enrolment table besides the students table . make sure no repetition in the results .",
    "predicted_parse_explanation": [
      "Step 1: for each row in students table , find the corresponding rows in addresses table",
      "Step 2: find the last name of the results of step 1 whose state province county equals NorthCarolina",
      "Step 3: find the last name in students table",
      "Step 4: show the rows that are in the results of step 2 but not in the results of step 3"
    ],
    "primary_span": [
      [
        4,
        12
      ],
      [
        18,
        25
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ]
    ],
    "edits": [
      "distinct",
      "student enrolment"
    ],
    "edits_original": "< select > add distinct </ select > < from > add student enrolment </ from >"
  },
  {
    "question": "Show the names of high schoolers who have at least 3 friends.",
    "db_id": "network_1",
    "gold_parse": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  3",
    "feedback": "Replace id in high schooler table with student id in friend table in step 1.",
    "predicted_parse_with_values": "select name from Highschooler group by ID having count ( * ) > = 3",
    "template_feedback": "in step 1 , additionally use the information from the friend table besides the high schooler table .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of id in high schooler table",
      "Step 2: find the name in high schooler table whose corresponding value in step 1 is greater than or equals 3"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        12,
        17
      ]
    ],
    "edits": [
      "friend",
      "student id",
      "id"
    ],
    "edits_original": "< from > add friend </ from > < groupBy > add student id </ groupBy > < groupBy > remove id </ groupBy >"
  },
  {
    "question": "What are the id, name and membership level of visitors who have spent the largest amount of money in total in all museum tickets?",
    "db_id": "museum_visit",
    "gold_parse": "SELECT t2.visitor_id ,  t1.name ,  t1.Level_of_membership FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id GROUP BY t2.visitor_id ORDER BY sum(t2.Total_spent) DESC LIMIT 1",
    "feedback": "In step 2 , Use customer id in place of museum id",
    "predicted_parse_with_values": "select T1.ID , T1.Name , T1.Level_of_membership from visitor as T1 join visit as T2 on T1.ID = T2.visitor_ID group by T2.Museum_ID order by sum ( T2.Total_spent ) desc limit 1",
    "template_feedback": "in step 2 , find for each value of customer id in place of museum id .",
    "predicted_parse_explanation": [
      "Step 1: for each row in customer table , find the corresponding rows in visit table",
      "Step 2: find the summation of total spent of each value of museum id of the results of step 1",
      "Step 3: find the customer id , name , level of membership of the results of step 1 with largest value in the results of step 2"
    ],
    "primary_span": [
      [
        4,
        10
      ]
    ],
    "secondary_span": [
      [
        11,
        16
      ]
    ],
    "edits": [
      "customer id",
      "museum id"
    ],
    "edits_original": "< groupBy > add customer id </ groupBy > < groupBy > remove museum id </ groupBy >"
  },
  {
    "question": "Give the name, year of independence, and surface area of the country that has the lowest population.",
    "db_id": "world_1",
    "gold_parse": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1",
    "feedback": "Supersede smallest value of surface area with smallest value of population",
    "predicted_parse_with_values": "select Name , IndepYear , SurfaceArea from country order by SurfaceArea asc limit 1",
    "template_feedback": "order the results by population in place of surface area .",
    "predicted_parse_explanation": [
      "find the name , indepdent year , surface area in country table with smallest value of surface area"
    ],
    "primary_span": [
      [
        0,
        4
      ]
    ],
    "secondary_span": [
      [
        5,
        10
      ]
    ],
    "edits": [
      "population",
      "surface area"
    ],
    "edits_original": "< orderBy > add population </ orderBy > < orderBy > remove surface area </ orderBy >"
  },
  {
    "question": "List singer names and number of concerts for each singer.",
    "db_id": "concert_singer",
    "gold_parse": "SELECT T2.name ,  count(*) FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id GROUP BY T2.singer_id",
    "feedback": "Also find corresponding number of concert id from singer in concert table for each name",
    "predicted_parse_with_values": "select Name , count ( * ) from singer group by Name",
    "template_feedback": "additionally use the information from the singer in concert table besides the singer table . find for each value of singer 's singer id in place of name .",
    "predicted_parse_explanation": [
      "find each value of name in singer table along with the number of the corresponding rows to each value"
    ],
    "primary_span": [
      [
        0,
        9
      ],
      [
        15,
        23
      ]
    ],
    "secondary_span": [
      [
        10,
        14
      ],
      [
        24,
        28
      ]
    ],
    "edits": [
      "singer in concert",
      "singer id",
      "name"
    ],
    "edits_original": "< from > add singer in concert </ from > < groupBy > add singer id </ groupBy > < groupBy > remove name </ groupBy >"
  },
  {
    "question": "What are the population and life expectancies in Brazil?",
    "db_id": "world_1",
    "gold_parse": "SELECT Population ,  LifeExpectancy FROM country WHERE Name  =  \"Brazil\"",
    "feedback": "Replace continent with name",
    "predicted_parse_with_values": "select Population , LifeExpectancy from country where Continent = \"Brazil\"",
    "template_feedback": "consider the name equals Brazil conditions in place of the continent equals Brazil conditions .",
    "predicted_parse_explanation": [
      "find the population and life expectancy in country table whose continent equals Brazil"
    ],
    "primary_span": [
      [
        0,
        5
      ]
    ],
    "secondary_span": [
      [
        6,
        14
      ]
    ],
    "edits": [
      "name equals \"Brazil\"",
      "continent equals \"Brazil\""
    ],
    "edits_original": "< where > add name equals \" Brazil \" </ where > < where > remove continent equals \" Brazil \" </ where >"
  },
  {
    "question": "What are the major record formats of orchestras, sorted by their frequency?",
    "db_id": "orchestra",
    "gold_parse": "SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC",
    "feedback": "Should be ordered ascending by number of rows of each value of major record format",
    "predicted_parse_with_values": "select Major_Record_Format from orchestra order by Major_Record_Format asc",
    "template_feedback": "find for each value of major record format . order the results by number of rows in place of major record format .",
    "predicted_parse_explanation": [
      "find the major record format in orchestra table ordered ascending by major record format"
    ],
    "primary_span": [
      [
        0,
        8
      ],
      [
        9,
        15
      ]
    ],
    "secondary_span": [
      [
        16,
        22
      ]
    ],
    "edits": [
      "major record format",
      "number of rows",
      "major record format"
    ],
    "edits_original": "< groupBy > add major record format </ groupBy > < orderBy > add number of rows </ orderBy > < orderBy > remove major record format </ orderBy >"
  },
  {
    "question": "Show the names of conductors that have conducted more than one orchestras.",
    "db_id": "orchestra",
    "gold_parse": "SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID HAVING COUNT(*)  >  1",
    "feedback": "In step 1 , Swap name in conductor table with conductor id in orchestra table.",
    "predicted_parse_with_values": "select Name from conductor group by Name having count ( * ) > 1",
    "template_feedback": "in step 1 , additionally use the information from the orchestra table besides the conductor table . find for value of orchestra 's conductor id in place of name .",
    "predicted_parse_explanation": [
      "Step 1: find the number of rows of each value of name in conductor table",
      "Step 2: find the name in conductor table whose corresponding value in step 1 is greater than 1"
    ],
    "primary_span": [
      [
        4,
        11
      ],
      [
        17,
        24
      ]
    ],
    "secondary_span": [
      [
        12,
        16
      ],
      [
        25,
        29
      ]
    ],
    "edits": [
      "orchestra",
      "conductor id",
      "name"
    ],
    "edits_original": "< from > add orchestra </ from > < groupBy > add conductor id </ groupBy > < groupBy > remove name </ groupBy >"
  },
  {
    "question": "What is the number of makers of care in France?",
    "db_id": "car_1",
    "gold_parse": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france'",
    "feedback": "Switch countries table with car makers table. Ensure correspondence.",
    "predicted_parse_with_values": "select count ( * ) from countries where CountryName = \"france\"",
    "template_feedback": "additionally use the information from the car makers table besides the countries table .",
    "predicted_parse_explanation": [
      "find the number of rows in countries table whose country name equals france"
    ],
    "primary_span": [
      [
        0,
        8
      ]
    ],
    "secondary_span": [
      [
        9,
        13
      ]
    ],
    "edits": [
      "car makers"
    ],
    "edits_original": "< from > add car makers </ from >"
  },
  {
    "question": "What languages are only used by a single country with a republic government?",
    "db_id": "world_1",
    "gold_parse": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  \"Republic\" GROUP BY T2.Language HAVING COUNT(*)  =  1",
    "feedback": "In step 2 , find language for each value of countrycode",
    "predicted_parse_with_values": "select T2.Language from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T1.GovernmentForm = \"Republic\"",
    "template_feedback": "in step 2 , find for each value of language whose number of rows equals 1 .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the language of the results of step 1 whose government form equals Republic"
    ],
    "primary_span": [
      [
        4,
        16
      ]
    ],
    "secondary_span": [],
    "edits": [
      "language",
      "number of rows equals 1"
    ],
    "edits_original": "< groupBy > add language </ groupBy > < having > add number of rows equals 1 </ having >"
  },
  {
    "question": "Find the average age of the dogs who went through treatments.",
    "db_id": "dog_kennels",
    "gold_parse": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )",
    "feedback": "Should find for dogs whose corresponding dog id present in treatments table.",
    "predicted_parse_with_values": "select avg ( age ) from Dogs",
    "template_feedback": "additionally make sure that dog id is one of treatments 's dog id treatments .",
    "predicted_parse_explanation": [
      "find the average age in dogs table"
    ],
    "primary_span": [
      [
        0,
        14
      ]
    ],
    "secondary_span": [],
    "edits": [
      "dog id one of SUBS1",
      "dog id",
      "treatments"
    ],
    "edits_original": "< where > add dog id one of SUBS1 </ where > < select > add dog id </ select > < from > add treatments </ from >"
  },
  {
    "question": "Give the name of the student with the most likes.",
    "db_id": "network_1",
    "gold_parse": "SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
    "feedback": "In step 1 , Put likes table in place of friend table.",
    "predicted_parse_with_values": "select T1.name from Highschooler as T1 join Friend as T2 on T1.ID = T2.friend_id group by T2.student_id order by count ( * ) desc limit 1",
    "template_feedback": "in step 1 , use likes table in place of friend table",
    "predicted_parse_explanation": [
      "Step 1: for each row in high schooler table , find the corresponding rows in friend table",
      "Step 2: find the number of rows of each value of student id of the results of step 1",
      "Step 3: find the name of the results of step 1 with largest value in the results of step 2"
    ],
    "primary_span": [
      [
        4,
        6
      ]
    ],
    "secondary_span": [
      [
        7,
        11
      ]
    ],
    "edits": [
      "likes",
      "friend"
    ],
    "edits_original": "< from > add likes </ from > < from > remove friend </ from >"
  },
  {
    "question": "Return the codes of countries that do not speak English and do not have Republics for governments.",
    "db_id": "world_1",
    "gold_parse": "SELECT Code FROM country WHERE GovernmentForm != \"Republic\" EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
    "feedback": "Step 2 , Switch language with \"GovernmentForm\".Step 4 , Find country 's code which are not in step 2 , 3.",
    "predicted_parse_with_values": "select T1.Code from country as T1 join countrylanguage as T2 on T1.Code = T2.CountryCode where T2.Language = \"English\" except select T3.Code from country as T3 join countrylanguage as T4 on T3.Code = T4.CountryCode where T4.Language = \"English\"",
    "template_feedback": "in step 1 , do not use the countrylanguage table . in step 2 , consider the government form not equals Republic conditions in place of the language equals English conditions . in step 3 , do not use the country table .",
    "predicted_parse_explanation": [
      "Step 1: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 2: find the code of the results of step 1 whose language equals English",
      "Step 3: for each row in country table , find the corresponding rows in countrylanguage table",
      "Step 4: find the code of the results of step 3 whose language equals English",
      "Step 5: show the rows that are in the results of step 2 but not in the results of step 4"
    ],
    "primary_span": [
      [
        4,
        10
      ],
      [
        15,
        22
      ],
      [
        36,
        42
      ]
    ],
    "secondary_span": [
      [
        4,
        10
      ],
      [
        23,
        31
      ],
      [
        36,
        42
      ]
    ],
    "edits": [
      "countrylanguage",
      "government form not equals to \"Republic\"",
      "language equals \"English\"",
      "countrycode",
      "code",
      "country"
    ],
    "edits_original": "< from > remove countrylanguage </ from > < where > add government form not equals to \" Republic \" </ where > < where > remove language equals \" English \" </ where > < select > add countrycode </ select > < select > remove code </ select > < from > remove country </ from >"
  },
  {
    "question": "Return the number of United Airlines flights leaving from AHD Airport.",
    "db_id": "flight_2",
    "gold_parse": "SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  \"United Airlines\" AND T2.SourceAirport  =  \"AHD\"",
    "feedback": "Find count of flights 's airlines whose source airport equals AHD , and corresponding airlines 's airlines equals United airlines",
    "predicted_parse_with_values": "select count ( * ) from airports where AirportName = \"AHD\"",
    "template_feedback": "use flights table and airlines table in place of airports table . consider the source airport equals AHD and airlines 's airline name equals United Airlines conditions in place of the airport name equals AHD conditions .",
    "predicted_parse_explanation": [
      "find the number of rows in airports table whose airport name equals AHD"
    ],
    "primary_span": [
      [
        0,
        5
      ],
      [
        12,
        26
      ]
    ],
    "secondary_span": [
      [
        6,
        11
      ],
      [
        27,
        36
      ]
    ],
    "edits": [
      "airlines",
      "flights",
      "airports",
      "airline name equals \"United Airlines\"",
      "source airport equals \"AHD\"",
      "airport name equals \"AHD\""
    ],
    "edits_original": "< from > add airlines </ from > < from > add flights </ from > < from > remove airports </ from > < where > add airline name equals \" United Airlines \" </ where > < where > add source airport equals \" AHD \" </ where > < where > remove airport name equals \" AHD \" </ where >"
  },
  {
    "question": "In 1980, how many cars were made?",
    "db_id": "car_1",
    "gold_parse": "SELECT count(*) FROM CARS_DATA WHERE YEAR  =  1980",
    "feedback": "only use the table cars data , delete step 1",
    "predicted_parse_with_values": "select count ( * ) from cars_data as T1 join car_names as T2 on T1.Id = T2.MakeId where T1.Year = 1980",
    "template_feedback": "in step 1 , do not use the car names table .",
    "predicted_parse_explanation": [
      "Step 1: for each row in cars data table , find the corresponding rows in car names table",
      "Step 2: find the number of rows of the results of step 1 whose year equals 1980"
    ],
    "primary_span": [
      [
        4,
        11
      ]
    ],
    "secondary_span": [
      [
        4,
        11
      ]
    ],
    "edits": [
      "car names"
    ],
    "edits_original": "< from > remove car names </ from >"
  },
  {
    "question": "How many flights fly from Aberdeen to Ashley?",
    "db_id": "flight_2",
    "gold_parse": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRPORTS AS T3 ON T1.SourceAirport  =  T3.AirportCode WHERE T2.City  =  \"Ashley\" AND T3.City  =  \"Aberdeen\"",
    "feedback": "In step 2 ensure source airport 's airport name equals Aberdeen and destination airport 's airport name equals Ashley.",
    "predicted_parse_with_values": "select count ( * ) from flights as T1 join airports as T2 on T1.DestAirport = T2.AirportCode where T2.AirportName = \"Aberdeen\" and T1.DestAirport = \"Ashley\"",
    "template_feedback": "in step 2 , consider the city equals Ashley and city equals Aberdeen conditions in place of the airport name equals Aberdeen and destination airport equals Ashley conditions .",
    "predicted_parse_explanation": [
      "Step 1: for each row in flights table , find the corresponding rows in airports table",
      "Step 2: find the number of rows of the results of step 1 whose airport name equals Aberdeen and destination airport equals Ashley"
    ],
    "primary_span": [
      [
        4,
        13
      ]
    ],
    "secondary_span": [
      [
        14,
        28
      ]
    ],
    "edits": [
      "airports",
      "city equals \"Ashley\"",
      "city equals \"Aberdeen\"",
      "airport name equals \"Aberdeen\"",
      "destination airport equals \"Ashley\""
    ],
    "edits_original": "< from > add airports </ from > < where > add city equals \" Ashley \" </ where > < where > add city equals \" Aberdeen \" </ where > < where > remove airport name equals \" Aberdeen \" </ where > < where > remove destination airport equals \" Ashley \" </ where >"
  },
  {
    "question": "Find the minimum grade of students who have no friends.",
    "db_id": "network_1",
    "gold_parse": "SELECT min(grade) FROM Highschooler WHERE id NOT IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)",
    "feedback": "In Step 2 , Swap second  grade with  'ID",
    "predicted_parse_with_values": "select min ( grade ) from Highschooler where grade not in ( select student_id from Friend )",
    "template_feedback": "in step 1 , additionally use the information from the high schooler table besides the friend table . in step 2 , make sure the id is not one of the results of step 1 the grade is not one of the results of step 1 .",
    "predicted_parse_explanation": [
      "Step 1: find the student id in friend table",
      "Step 2: find the minimum grade in high schooler table whose grade not one of the results of step 1"
    ],
    "primary_span": [
      [
        4,
        12
      ],
      [
        22,
        34
      ]
    ],
    "secondary_span": [
      [
        13,
        17
      ],
      [
        35,
        46
      ]
    ],
    "edits": [
      "id not one of SUBS1",
      "grade not one of SUBS1",
      "high schooler"
    ],
    "edits_original": "< where > add id not one of SUBS1 </ where > < where > remove grade not one of SUBS1 </ where > < from > add high schooler </ from >"
  },
  {
    "question": "How many car models were produced by the maker with full name American Motor Company?",
    "db_id": "car_1",
    "gold_parse": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker WHERE T1.FullName  =  'American Motor Company'",
    "feedback": "Swap car makers table with model list table and ensure correspondence as well.",
    "predicted_parse_with_values": "select count ( * ) from car_makers where FullName = \"American Motor Company\"",
    "template_feedback": "additionally use the information from the model list table besides the car makers table .",
    "predicted_parse_explanation": [
      "find the number of rows in car makers table whose full name equals American Motor Company"
    ],
    "primary_span": [
      [
        0,
        8
      ]
    ],
    "secondary_span": [
      [
        9,
        14
      ]
    ],
    "edits": [
      "model list"
    ],
    "edits_original": "< from > add model list </ from >"
  }
]